<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>lucene中的FST算法分析 | MR.GUAN</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言
FST（Finite State Transducer，一种有限自动机，或者称为Mealy machine）是lucene中的一个核心算法，用于检索term信息存储的位置。在lucene中，term按照文本的字典顺序排序，term其它相关信息按次序存储在磁盘上。在Lucene运行过程中，由term文本构成的FST存放在内存中，通过FST能够检索出term在硬盘中的具体存储位置。
在FST构建">
<meta property="og:type" content="article">
<meta property="og:title" content="lucene中的FST算法分析">
<meta property="og:url" content="http://guanxinquan.github.io/blog/blog/2014/06/17/lucene_FST_parser/">
<meta property="og:site_name" content="MR.GUAN">
<meta property="og:description" content="前言
FST（Finite State Transducer，一种有限自动机，或者称为Mealy machine）是lucene中的一个核心算法，用于检索term信息存储的位置。在lucene中，term按照文本的字典顺序排序，term其它相关信息按次序存储在磁盘上。在Lucene运行过程中，由term文本构成的FST存放在内存中，通过FST能够检索出term在硬盘中的具体存储位置。
在FST构建">
<meta property="og:image" content="/blog/pic/lucene_fst/final_fst.jpg">
<meta property="og:image" content="/blog/pic/lucene_fst/mop_input.jpg">
<meta property="og:image" content="/blog/pic/lucene_fst/month_input.jpg">
<meta property="og:image" content="/blog/pic/lucene_fst/month_input_2.jpg">
<meta property="og:image" content="/blog/pic/lucene_fst/month_input_3.jpg">
<meta property="og:image" content="/blog/pic/lucene_fst/month_input_4.jpg">
<meta property="og:image" content="/blog/pic/lucene_fst/month_input_5.jpg">
<meta property="og:image" content="/blog/pic/lucene_fst/start_input.jpg">
<meta property="og:image" content="/blog/pic/lucene_fst/stop_input_1.jpg">
<meta property="og:image" content="/blog/pic/lucene_fst/stop_input_2.jpg">
<meta property="og:image" content="/blog/pic/lucene_fst/top_input.jpg">
<meta property="og:image" content="/blog/pic/lucene_fst/final.jpg">
<meta property="og:image" content="/blog/pic/lucene_fst/37_output.jpg">
<meta property="og:image" content="/blog/pic/lucene_fst/9_output.jpg">
<meta property="og:image" content="/blog/pic/lucene_fst/7_output.jpg">
<meta property="og:image" content="/blog/pic/lucene_fst/2_output.jpg">
<meta property="og:image" content="/blog/pic/lucene_fst/13_output.jpg">
<meta property="og:image" content="/blog/pic/lucene_fst/11_output.jpg">
<meta property="og:image" content="/blog/pic/lucene_fst/23_output.jpg">
<meta property="og:image" content="/blog/pic/lucene_fst/21_output.jpg">
<meta property="og:image" content="/blog/pic/lucene_fst/15_output.jpg">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lucene中的FST算法分析">
<meta name="twitter:description" content="前言
FST（Finite State Transducer，一种有限自动机，或者称为Mealy machine）是lucene中的一个核心算法，用于检索term信息存储的位置。在lucene中，term按照文本的字典顺序排序，term其它相关信息按次序存储在磁盘上。在Lucene运行过程中，由term文本构成的FST存放在内存中，通过FST能够检索出term在硬盘中的具体存储位置。
在FST构建">
  
    <link rel="alternative" href="/atom.xml" title="MR.GUAN" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/blog/css/style.css" type="text/css">
  
</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog//" id="logo">MR.GUAN</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog//">Home</a>
        
          <a class="main-nav-link" href="/blog//archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="submit" value="&#xF002;" class="search-form-submit"><input type="hidden" name="q" value="site:http://guanxinquan.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-lucene_FST_parser" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2014/06/17/lucene_FST_parser/" class="article-date">
  <time datetime="2014-06-17T09:39:40.000Z" itemprop="datePublished">Jun 17 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/算法/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      lucene中的FST算法分析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言">前言</h1>
<p>FST（Finite State Transducer，一种有限自动机，或者称为Mealy machine）是lucene中的一个核心算法，用于检索term信息存储的位置。在lucene中，term按照文本的字典顺序排序，term其它相关信息按次序存储在磁盘上。在Lucene运行过程中，由term文本构成的FST存放在内存中，通过FST能够检索出term在硬盘中的具体存储位置。</p>
<p>在FST构建过程中，term的文本信息(按照字典顺序排序）作为FST的input，term的存储位置（或者次序）作为FST的output，<input,output>二元组将以FST的形式存储在内存中（<strong>请注意input和output都是有序的</strong>）。检索时，根据input，通过计算FST中的路径上的权值信息，获取到output数据，最终在磁盘上定位term的其它附加信息。同时FST还能够快速的判断一个term是否在lucene中。<br><a id="more"></a><br>实际上FST相当于term在内存中的一个索引，lucene使用FST能够快速确定系统中是否存在查询的term，如果存在，能够快速定位其信息存放的具体位置。</input,output></p>
<p>FST与trie tree结构提供相似的功能，但是，在内存中存储更高效。</p>
<p>举个例子，我们输入FST的数据如下：</p>
<pre><code>String inputValues[] = {<span class="string">"mop"</span>,<span class="string">"moth"</span>,<span class="string">"pop"</span>,<span class="string">"star"</span>,<span class="string">"stop"</span>,<span class="string">"top"</span>};
<span class="keyword">long</span> outputValues[] = {<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>};
</code></pre><p>最终获得的FST图：</p>
<p><img src="/blog/pic/lucene_fst/final_fst.jpg" alt="最终生成的FST图"></p>
<p>从上图我们可以计算每个term的文本对应的output值，例如我们要计算stop：</p>
<ol>
<li>s-&gt;23  的弧线s/3(s表示起始节点),</li>
<li>23-&gt;21 的弧线t,</li>
<li>21-&gt;11 的弧线o/1，</li>
<li>11-&gt;E  的弧线p（E表示终止节点）。</li>
</ol>
<p>因此，<code>3+0+1+0=4</code>，因此，stop对应的值为4.</p>
<h1 id="FST的构建">FST的构建</h1>
<h2 id="数据结构">数据结构</h2>
<h3 id="FST_bytes">FST bytes</h3>
<p>FST中的bytes数组，存储FST数据信息。FST bytes存储了FST图的完整信息（通过FST bytes，可以构建一个FST图）。</p>
<h3 id="FST_node">FST node</h3>
<p>表示FST图的一个节点，有两种实现类型，UnCompiledNode（尚未存放到FST bytes中的节点）和CompiledNode（已经存放到FST bytes中的节点）。这个结构在FST构建过程中用于存储临时数据。</p>
<h3 id="FST_arc">FST arc</h3>
<p>用于表示Node间的弧线，在构建FST时，存储两个FST node节点间的弧线信息（弧线的表示的字符和弧线上的权值）。</p>
<h3 id="FST_HashMap">FST HashMap</h3>
<p>一个使用探测法实现的HashMap，key是FST Node生成的hash值，value是FST node存放在FST bytes数组中的下标。（<strong>FST HashMap不是构建FST必须的组成部分，但是，HashMap能够加快判断某个节点是否已经在FST bytes中，HashMap仅用于FST的构建过程</strong>）。</p>
<h3 id="Frontier">Frontier</h3>
<p>是一个数组，用于存放未转换到FST byte数组中的数据信息。</p>
<p><em>为了能够理解FST的构建过程，需要先分析Hash算法。</em></p>
<p><em>Hash算法并不是FST中必不可缺的部分，在构建过程中FST使用HashMap来快速判断测试节点(node)是否已经被写入到FST bytes中。HashMap的value是node在FST bytes数组中的实际存储位置（数组的下标）。<br>HashMap中的key通过计算节点中所有的arcs信息生成的。其中，每个arc被考虑的属性包括，label（字符）、targetNode（下一个节点的地址）、outPut（节点输出）、isFinal（是否是终止弧线）、nextFinal（下一个终止弧线—这个参数在测试过程中没有发现被赋值）。</em></p>
<p><em>例如：将node1添加到FST bytes时，先通过hash算法计算node1对应的key，如果key在Hashmap中已经有对应的值value，那么这个value就是与node1 hash值相同的节点（称为node2）存储在FST bytes中的实际数组下标，FST从bytes数组中转换出node2，判断node1和node2是否相等（所有的arc值是否相等），如果相等，node1就没有必要再添加到FST bytes中（相当于FST的尾部进行了归并）。</em></p>
<h2 id="算法的基本步骤">算法的基本步骤</h2>
<ol>
<li>计算公共前缀。对于新输入的NInput（new input），首先要计算其与上次输出的LInput（Lastest input，LInput数据存放在Frontier中）之间的公共前缀prefix，之后调用freezeTail，将Frontier中的LInput的后缀转换到FST bytes数组中（<strong>需要注意，输入的数据（label）是按照字典顺序有序的，因此求公共前缀的时候，只需要和NInput的前一个输入节点对比即可,后缀是指，除了公共前缀和公共前缀直接后继节点外的节点，例如：aaabc和aacae的公共前缀是aa，此时aaabc的后缀是bc</strong>）。</li>
<li>将后缀部分存储到FST bytes中。在freezeTail过程中，会将LInput的后缀，从后向前的顺序逐个存储到FST bytes中，每个节点的存储步骤如下，<br>2.1  node通过Hash算法判断其是否已经在bytes中，进行如下操作：<br>2.1.1  HashMap中找不到key对应的value，将新节点添加到FST bytes中（<strong>添加节点，实际是将节点包含的所有arc都写入到FST bytes中，并不是将节点本身写入FST bytes中</strong>）；<br>2.1.2  HashMap中找到key对应的value，从FST bytes中转换出preNode，可能出现下面的两种情况：<br>与当前node的值相等，直接返回preNode的存储位置pos相当于尾部节点的合并。<br>如果不相等，那么继续探测，回到步骤2.1。</li>
</ol>
<h2 id="构建过程模拟">构建过程模拟</h2>
<h3 id="FST_bytes中的Flag字段含义">FST bytes中的Flag字段含义</h3>
<p>每个arc存储在FST bytes中都会有一个flag字段，FST通过flag字段可以判断出FST bytes中有几个bytes与当前arc相关，并且携带了包含当前arc节点的出度信息等。arc的含义如下：</p>
<ul>
<li>Final arc： 1         表示这是一个Final arc，arc指向一个终止状态E。</li>
<li>Last arc：2        表示arc是包含当前arc的节点的最后一个arc；</li>
<li>Target next：4       当前arc的下一个arc（FST图上的下一个）是包含当前arc的节点的最后一个arc的前驱arc（FST bytes数组位置，向前邻接的那个arc）。</li>
<li>Stop node：8        终止状态E。</li>
<li>Has output: 16    当前arc有output值（表示output不为0）</li>
</ul>
<h3 id="构建过程">构建过程</h3>
<p>input和output的数据如下：</p>
<pre><code>String inputValues[] = {<span class="string">"mop"</span>,<span class="string">"moth"</span>,<span class="string">"pop"</span>,<span class="string">"star"</span>,<span class="string">"stop"</span>,<span class="string">"top"</span>};
<span class="keyword">long</span> outputValues[] = {<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>};
</code></pre><h4 id="输入mop">输入mop</h4>
<p><img src="/blog/pic/lucene_fst/mop_input.jpg" alt="after mop input"></p>
<p>输入mop后，m/o/p三个弧线的信息都保存在frontier中（frontier表示尚未存放到FST bytes中的数据）。FSTbytes数据为空。</p>
<h4 id="输入moth">输入moth</h4>
<p><img src="/blog/pic/lucene_fst/month_input.jpg" alt="after month input"></p>
<p>输入moth时，moth与先前的mop有mo两个公共前缀，在freezeTail过程中，将先前弧线p后面的节点（节点3）存储到FST bytes中，由于节点3没有任何出度，因此FSTbytes中的数据仍然是空，而p的下一个节点是FSTbytes中的-1的位置（-1 表示终止）。之后将th添加到frontier中，增加两个弧线t/1和h。</p>
<h4 id="输入pop">输入pop</h4>
<p>输入pop后，pop与moth没有公共的前缀，因此在freezeTail过程中，需要将frontier中的4,3,2,1都存储到FST bytes中。<br> 1 . 由于4没有出度，因此3-&gt;4的h弧度的下一节点为-1。<br> 2 . 存储节点3，有一个出度3-&gt;4，值为h，因此如下图：11表示8+2+1=stopNode(-1)+lastArc+FinalArc。stopNode说明当前弧是一个指向终点的弧（stopNode，FinalArc），并且当前弧是当前节点的最后一条弧线（FinalArc）。104是h的ascii值。<br><img src="/blog/pic/lucene_fst/month_input_2.jpg" alt="after month input"></p>
<p>注：在每个节点被写入后，会将这个节点的所有数据倒置，写入结束后，FST bytes变为（0,104,11）。数组0的位置永远存储的是0.<br> 3 . 存储节点2，节点2有两个弧度：<br><em>先写入p，9和112。9= stop_node+ final_arc，表示弧线p是终止节点。
</em>写入t/1，22、116 和1。22表示16 + 4 + 2 = has_output + targetNext + last_arc，说明，t/1这个弧线有output，弧线的后继弧线是紧邻着的那条（就是FST bytes中左侧（小端）的那条）并且是当前节点的最后一个arc</p>
<p>(<strong>注：由于存储结束后fst会将节点的所有arcs数据倒置，因此与t/1邻接的弧线就是h那条弧线，反转后，如下图：可以看出t/1的向前邻接的节点是h。</strong>）</p>
<p><img src="/blog/pic/lucene_fst/month_input_3.jpg" alt="after month input"></p>
<p> 4 . 存储节点1并反转后，6 表示target_next和last_arc.</p>
<p><img src="/blog/pic/lucene_fst/month_input_4.jpg" alt="after month input"></p>
<p> 5 . freezeTail结束后，将pop放入frontier中。如下图。</p>
<p><img src="/blog/pic/lucene_fst/month_input_5.jpg" alt="after month input"></p>
<h4 id="输入start">输入start</h4>
<p><img src="/blog/pic/lucene_fst/start_input.jpg" alt="after start input"></p>
<h4 id="输入stop">输入stop</h4>
<p><img src="/blog/pic/lucene_fst/stop_input_1.jpg" alt="after stop input"></p>
<p><img src="/blog/pic/lucene_fst/stop_input_2.jpg" alt="after stop input"></p>
<h4 id="输入top">输入top</h4>
<p><img src="/blog/pic/lucene_fst/top_input.jpg" alt="after top input"></p>
<h4 id="最后的结果">最后的结果</h4>
<p><img src="/blog/pic/lucene_fst/final.jpg" alt="after final input"></p>
<h3 id="还原FST图">还原FST图</h3>
<p>FST bytes数组中存储了FST图的完整信息，因此，我们可以根据FST bytes中的数据，转换出FST图，下面我们描述这个转换过程。<br>由 FST bytes 数组中的24-37可以获得第一个节点的出度：</p>
<h5 id="第一个节点37号开始">第一个节点37号开始</h5>
<ol>
<li>37 flag为0，表示不是last arc，不是Target_next，不是has_output.不是last_arc表示邻接的是兄弟arc，不是has_output表示没有输出，不是target_next表示存储了arc的下一个arc的地址，因此9位置表示下一个arc的起始地址。</li>
<li>34 flag为16 表示有output，没有last arc，邻接的是兄弟arc，没有target_next，因此，2是output，13是下一个arc的位置。</li>
<li>30 flag 为20 表示有output，没有last arc，有target_next，因此3表示output，邻接的是兄弟arc，节点所有的arc读出后，邻接的arc是当前arc的下一个节点。</li>
<li>27 flag 为18 表示有output，是last arc，不是target_next,不是final。当前arc的下一个arc为13，output是5. 因此步骤3的下一个arc是23.（因为27表示的arc已经是当前节点的最后一个arc（即last_arc），因此邻接的节点23是标有target_next（就是30那个）的下一个arc）。</li>
</ol>
<p><img src="/blog/pic/lucene_fst/37_output.jpg" alt="after 37 output"></p>
<h5 id="9的出度">9的出度</h5>
<p>由9的出度得到如下：flag是6，是last_arc和target_next，因此7是当前arc的下一个arc，而且当前节点仅有一个出度。</p>
<p><img src="/blog/pic/lucene_fst/9_output.jpg" alt="after 9 output"></p>
<h5 id="7的出度">7的出度</h5>
<p>flag是9，表示是一个终点arc，arc的指向结束状态E。并且不是last_arc，因此，5就是其兄弟节点。<br>5 flag是22，has_output,target_next,last_arc，因此1是output，并且是本节点最后的arc，当前arc的下一个arc，是邻接的那一个（就是2那个）。</p>
<p><img src="/blog/pic/lucene_fst/7_output.jpg" alt="after 7 output"></p>
<h5 id="2的出度">2的出度</h5>
<p>由2的出度如下，flag是11，表示stop_node, final_arc,last_arc，因此当前arc是当前节点的最后一条arc，并且是一个终止arc。</p>
<p><img src="/blog/pic/lucene_fst/2_output.jpg" alt="after 2 output"></p>
<h5 id="13的出度">13的出度</h5>
<p><img src="/blog/pic/lucene_fst/13_output.jpg" alt="after 13 output"></p>
<h5 id="11的出度">11的出度</h5>
<p><img src="/blog/pic/lucene_fst/11_output.jpg" alt="after 11 output"></p>
<h5 id="23的出度">23的出度</h5>
<p><img src="/blog/pic/lucene_fst/23_output.jpg" alt="after 23 output"></p>
<h5 id="21的出度">21的出度</h5>
<p><img src="/blog/pic/lucene_fst/21_output.jpg" alt="after 21 output"></p>
<h5 id="15的出度">15的出度</h5>
<p><img src="/blog/pic/lucene_fst/15_output.jpg" alt="after 15 output"></p>
<h3 id="检索过程">检索过程</h3>
<p>cachedRootArcs 一个128个元素的arc数组，存储每个ascii字符对应的起始弧线。例如：要检索以a开始的term，cachedRootArcs[97]就是起始弧线。<br>注意，系统内部仅存储以S开始的那些弧线，其它弧线都是通过对FST的bytes数组计算获得。<br>因此，在term的查询过程中，首先通过cachedRootArcs获取term首字母对应的弧线（即其在数组中对应的下标位置），之后按照上面提到过的方式转换其它弧度，按照图的查找算法。如果要查找以某个term开始的所有terms，则按照上述方法，先查找到term，然后遍历这个term下的所有terms即可。</p>
<p>从分析可以看出，FST的这个索引在内存中仅用一个bytes数组，额外加上少量的cachedRootArcs数组空间，即可。是十分节省内存空间的，但是查询时可能比较消耗cpu的计算。</p>
<h1 id="小结">小结</h1>
<p>FST的算法十分复杂，描述和理解起来都比较困难，比较容易学习的方法就是看lucene的源码，通过debug的方式，查看关键数据结构中的值，来理解算法原理。笔者从看源码到理解花费了一周左右的时间。有兴趣的同学也可以自己去看看相应的源码。本文是以lucene4.8.0为基础分析的。</p>
<p>Lucene通过使用FST在内存中存储了term的一份索引，紧凑的数据格式（FST bytes数组），不但减少了内存使用量，还有效的提高了term的检索效率，是一个非常优秀的算法。</p>
<h1 id="参考资料">参考资料</h1>
<ul>
<li><a href="http://blog.mikemccandless.com/2010/12/using-finite-state-transducers-in.html" target="_blank" rel="external">http://blog.mikemccandless.com/2010/12/using-finite-state-transducers-in.html</a> （作者说明）</li>
<li>Direct Construction of Minimal Acyclic Subsequential Transducers. （算法的论文）</li>
<li>Applications of Deterministic Finite Automata. （有助于理解）</li>
<li><a href="http://sbp810050504.blog.51cto.com/2799422/1361551" target="_blank" rel="external">http://sbp810050504.blog.51cto.com/2799422/1361551</a> （中文资料，尽管有些误区）。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://guanxinquan.github.io/blog/2014/06/17/lucene_FST_parser/" data-id="5d08matmxgw9y5p7" class="article-share-link">Share</a>
      
        <a href="http://guanxinquan.github.io/blog/2014/06/17/lucene_FST_parser/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/fst/">fst</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2014/07/10/gc/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          java 虚拟机垃圾回收原理
        
      </div>
    </a>
  
  
    <a href="/blog/2014/06/17/firstblog/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">青春纪念</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/算法/">算法</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/fst/">fst</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/gc/">gc</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/redis/">redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/生活/">生活</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/fst/" style="font-size: NaNpx;">fst</a><a href="/blog/tags/gc/" style="font-size: NaNpx;">gc</a><a href="/blog/tags/redis/" style="font-size: NaNpx;">redis</a><a href="/blog/tags/生活/" style="font-size: NaNpx;">生活</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/10">October 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/07">July 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/06">June 2014</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2014/10/01/redis/">redis 算法研究</a>
          </li>
        
          <li>
            <a href="/blog/2014/07/10/gc/">java 虚拟机垃圾回收原理</a>
          </li>
        
          <li>
            <a href="/blog/2014/06/17/lucene_FST_parser/">lucene中的FST算法分析</a>
          </li>
        
          <li>
            <a href="/blog/2014/06/17/firstblog/">青春纪念</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2014 xinquan.guan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog//" class="mobile-nav-link">Home</a>
  
    <a href="/blog//archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'httpguanxinquangithubio';
  
  var disqus_url = 'http://guanxinquan.github.io/blog/2014/06/17/lucene_FST_parser/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//go.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/blog/js/script.js" type="text/javascript"></script>
  </div>
</body>
</html>