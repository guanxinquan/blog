<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>MR.GUAN</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="title: java 虚拟机垃圾回收原理date: 2014-07-10 22:37:01categorys: 算法
tag：GC
Hotspot GC

垃圾回收的基本概念
垃圾回收器主要负责：

为对象分配内存；
确保可执行代码能够访问到的对象保留在内存中；
无法被可执行代码访问到的对象占用的空间得到释放。">
<meta property="og:type" content="article">
<meta property="og:title" content="MR.GUAN">
<meta property="og:url" content="http://guanxinquan.github.io/blog/blog/2014/07/10/gc/">
<meta property="og:site_name" content="MR.GUAN">
<meta property="og:description" content="title: java 虚拟机垃圾回收原理date: 2014-07-10 22:37:01categorys: 算法
tag：GC
Hotspot GC

垃圾回收的基本概念
垃圾回收器主要负责：

为对象分配内存；
确保可执行代码能够访问到的对象保留在内存中；
无法被可执行代码访问到的对象占用的空间得到释放。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MR.GUAN">
<meta name="twitter:description" content="title: java 虚拟机垃圾回收原理date: 2014-07-10 22:37:01categorys: 算法
tag：GC
Hotspot GC

垃圾回收的基本概念
垃圾回收器主要负责：

为对象分配内存；
确保可执行代码能够访问到的对象保留在内存中；
无法被可执行代码访问到的对象占用的空间得到释放。">
  
    <link rel="alternative" href="/atom.xml" title="MR.GUAN" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/blog/css/style.css" type="text/css">
  
</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog//" id="logo">MR.GUAN</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog//">Home</a>
        
          <a class="main-nav-link" href="/blog//archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="submit" value="&#xF002;" class="search-form-submit"><input type="hidden" name="q" value="site:http://guanxinquan.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-gc" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2014/07/10/gc/" class="article-date">
  <time datetime="2014-07-10T13:11:03.000Z" itemprop="datePublished">Jul 10 2014</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: java 虚拟机垃圾回收原理<br>date: 2014-07-10 22:37:01<br>categorys: 算法</p>
<h2 id="tag：GC">tag：GC</h2>
<h1 id="Hotspot_GC">Hotspot GC</h1>
<p><br></p>
<h1 id="垃圾回收的基本概念">垃圾回收的基本概念</h1>
<p>垃圾回收器主要负责：</p>
<ol>
<li>为对象分配内存；</li>
<li>确保可执行代码能够访问到的对象保留在内存中；</li>
<li>无法被可执行代码访问到的对象占用的空间得到释放。<br><a id="more"></a><h2 id="设计特性选择">设计特性选择</h2>
<h3 id="串行和并行">串行和并行</h3>
串行垃圾回收器，在同一时间段内，即使是多核处理器情况下，垃圾回收仅有一个线程在执行。并行垃圾回收器，在垃圾回收的过程中，任务被分解成多个部分，并且各部分任务能够并行执行在不同的cpu上。并行垃圾回收能够降低垃圾回收消耗的时间，代价是复杂的逻辑和潜在的内存碎片。<h3 id="同步（concurrent）和暂停（stop_the_world）">同步（concurrent）和暂停（stop the world）</h3>
stop-the-world方式垃圾回收期间，应用程序的运行被完全暂停，而concurrent方式的垃圾回收过程中，一个或多个垃圾回收任务可以同时与应用程序并行运行。通常来说，concurrent方式的垃圾回收的多数回收任务能够和应用程序并行执行，但是，也需要短暂的stop-the-world暂停。stop-the-world相对于concurrent来说要简单的多，在stop-the-world垃圾回收过程中，整个heap区都会被锁住，在垃圾回收过程中，不会有任何的对象修改，他的缺点在于，对于某些应用来说，不能接受较长时间的stop-the-world暂停。concurrent垃圾回收的暂停时间相对较短，但是需要处理在垃圾回收期间，有可能被应用程序修改或者更新的对象，这回影响垃圾回收的效率并需要更大的堆空间。<h3 id="压缩（compacting）、不压缩（no-compacting）和拷贝（copying）">压缩（compacting）、不压缩（no-compacting）和拷贝（copying）</h3>
垃圾回收器确定哪些对象是垃圾对象后，可以将所有的对象都移动到heap的一端，回收heap另一端的空间。compacting后，分配新的对象将变的容易，一个简单的指针指向下一个将要被分配的heap空间位置，新的对象仅需从这个指针位置起，划分出足够的空间即可。no-compacting垃圾回收器，不会将所有的live对象紧凑的排在heap的一端，而是会记录（in-place）被释放对象的位置，他的优点在于能够快速的完成垃圾回收，缺陷在于潜在的内存碎片。通常意义讲，no-compacting方式要比compacting方式的垃圾回收，在内存分配过程中会更耗时，因为，从in-place表中找到一个大小适中的空间比直接移动指针要更耗时间。第三种可选的垃圾回收器是coping，将所有live的对象都紧凑的拷贝到另外的内存区域。优点在于，原有空间（source）变成空的，能够简单、快速、有序的分配，缺点在于拷贝对象需要消耗一定的时间和额外的存储空间。<h2 id="按代（Generational）回收器">按代（Generational）回收器</h2>
generational回收将内存分成多个generations，每个generation都是一个单独存放不同年龄段（ages）的对象池。最常见的是分成两个年龄代，新生代和老年代。<br>不同的年龄代可以有不同的垃圾回收算法。按代回收算法是基于如下假说：<br><em>大多数分配的对象不会存活较长时间，他们在年轻代就死亡；
</em>少量的年轻的对象能够在老年代出现。<br><br>年轻代垃圾回收相对要更频繁、更有效、更快速，因为年轻代的存储空间较小，并且存放的多数都是短期对象。<br><br>那些经历过指定次数年轻代垃圾回收的对象将会被晋级到老年代中。老年代的存储空间一遍要远大于年轻代，并且，存储对象占用的空间增长缓慢，因此，老年代垃圾回收频率很低，并且消耗更长时间。<br><br>由于年轻代垃圾回收比较频繁，因此选择收算法更关注于回收速度，另一方面，老年代垃圾算法要更关注空间效率，因为老年代占用了heap区域的大部分空间，并且要在较低的垃圾密度下更好的工作。<h1 id="java_HotSpot_JVM_GC">java HotSpot JVM GC</h1>
<h2 id="HotSpot_按代回收">HotSpot 按代回收</h2>
HotSpot JVM的内存被分为三代，分别是年轻代，老年代和永久（permanent）代，大多数Objects在年轻代中初始化。老年代中存放着经历了指定次数年轻代垃圾回收后仍然存活的对象，以及一些占用空间比较大的对象，他们很可能直接创建在老年代中。持久区存放一些方便JVM查找垃圾回收管理的对象信息，例如classes或者methods的描述对象和classes和methods本身。<br><br>年轻代由一个伊甸园（Eden）区和两个存活（survivor）区组成，大多数对象都在Eden区初始化。（有一部分比较大的对象，很可能直接分配在老年代中）。survivor区存放至少经历一次年轻代垃圾回收仍然存活的对象，并且还存在一定几率在晋升到old区之前无效的对象。在任何一个时间内，仅有一个survivor区保存存活对象，另外一个一直是空的，直到下次垃圾回收。<h2 id="垃圾回收类型">垃圾回收类型</h2>
年轻代空间耗尽后，年轻代垃圾回收就会执行。当老年代或者永久代耗尽，full collection就会执行。在full gc的过程中，所有年龄代都会被回收，一般来讲，由于年轻代能够最高效的定位哪些是垃圾，因此最先执行，之后是老年代的垃圾回收算法会在老年代和永久代执行。如果，垃圾回收还需要compacting，那么不同的代间分别执行compacted。<br><br>有时，老年代太满了，已经无法继续分配年轻代晋级过来的对象，此时，年轻代垃圾回收将不会执行，而是将在整个heap区域执行老年代垃圾回收算法（CMS算法除外，因为CMS老年代算法无法回收年轻代的空间）。<h2 id="快速分配">快速分配</h2>
在很多情况下，内存中会有大量的连续的空间用于分配对象，此时，使用偏移指针（bump-the-pointer）分配对象会很高效。指针只需要跟踪先前最后一个对象分配位置的结尾处，当有新的对象分配请求到来时，仅需要验证当前代中剩余的空间是否能够容纳新对象，如果能够承载，仅需要更新指针并初始化对象即可。<br><br>对于多线程应用，分配过程需要保证线程安全。如果使用锁控制，在代中分配空间将会变成瓶颈，并且影响性能。HotSpot使用Thread-Local Allocation Buffers（TLABs）算法，通过使每个现成拥有自己的buffer（代中的一小块区间），提高了并行程序分配内存的吞吐率。由于每个TLAB块仅有一个线程可以访问，因此，通过bump-the-pointer技术能够快速分配内存。例如：管理TLABs平均要消耗1%的Eden，结合使用线性分配（bump-the-pointer）每次的内存分配仅需要大概10个本地指令就能完成。<h2 id="Serial_Collector">Serial Collector</h2>
Serial collector，年轻代或者老年代回收都是stop-the-world方式串行执行（仅用一个cpu），即是说，在垃圾回收期间，整个应用程序都是暂停的。<h3 id="年轻代的串行回收">年轻代的串行回收</h3>
下图描述了使用串行化的年轻代回收方式。在Eden中存活的对象被拷贝到空的survivor区域中（图中to标记的区域），那些很大的对象有可能直接拷贝到老年代中。在非空的survivor区域中存活的并且被认为依然很年轻的对象（图中from）也会被拷贝到另一个survivor中，那些被认为应该晋升为老年区的对象将会被直接拷贝到老年代中。<strong>如果To区域已经满了，那面Eden区或者From survivor区剩余的对象将会直接拷贝到老年代，无论对象已经经历了多少次的年轻代gc</strong><br><br>年轻代回收结束后，Eden区域和先前的survivor区域都变成空的，只有先前空的survivor空间保留存活的对象，survivor空间将会调换角色。<h3 id="老年代串行回收">老年代串行回收</h3>
串行老年代回收过程中，老年代和持久代使用mark-sweep-compact算法，在mark阶段，收集器确定哪些对象依然存活，在sweep阶段，定义垃圾对象，之后，收集器使用滑动压缩，将存活的object都向老年代起始位置滑动（持久代同理），将连续的空闲的空间留在代的末尾。compacting使得在老年代或者持久代中能够使用bump-the-pointer技术快速分配对象。<h3 id="使用窜行收集器的时机">使用窜行收集器的时机</h3>
串行收集器可以在多数客户端应用上或者对短暂停（stop-the-world的时间）要求不敏感的需求。<h3 id="使用串行收集器">使用串行收集器</h3>
在java5.0版本中，对于非server-class机器，串行收集器是默认的选择，在其他机器上，可以通过-XX:+UseSerialGC命令显示指定使用串行收集器。<h2 id="Parallel_Collector">Parallel Collector</h2>
<h3 id="年轻代的回收">年轻代的回收</h3>
Parallel Collector使用Serial Collector的回收算法，但却是并行的版本。Parallel Collector也是stop-the-world和coping回收器，但是他能够利用多cpu并发处理年轻代的垃圾回收，降低了垃圾回收的成本，提高了应用程序的吞吐率。<h3 id="老年代的回收">老年代的回收</h3>
老年代的回收使用与Serial Collector一样的算法，既mark-sweep-compact垃圾回收算法。<h3 id="Parallel_Collector使用时机">Parallel Collector使用时机</h3>
由于Parallel Collector存在频率较低，潜在stop-the-world时间较长的老年代回收，因此，他适用于执行在多cpu机器上并且没有严格的暂停时间长度的限制应用程序。例如，批处理程序、账单程序、科学计算等。<h3 id="使用Parallel_Collector垃圾收集器">使用Parallel Collector垃圾收集器</h3>
Parallel Collector是jase5.0默认的服务（server-class）机器配置垃圾收集器。在其他的情况下，可以通过显示配置-XX:+UseParallelGC命令配置并行垃圾收集。<h2 id="Parallel_Compacting_Collector">Parallel Compacting Collector</h2>
Parallel Compacting Collector出现在j2se5.0 update 6. Parallel Compacting Collector与Parallel Collector的区别在于，老年代回收算法的不同。需要注意的是，Parallel Compacting Collector会作为Parallel Collector的替代品存在。<h3 id="Parallel_Compacting_Collector_年轻代收集算法">Parallel Compacting Collector 年轻代收集算法</h3>
与Parallel Collector年轻代回收算法相同。<h3 id="Parallel_Compacting_Collector_老年代回收算法">Parallel Compacting Collector 老年代回收算法</h3>
Parallel Compacting Collector老年代和持久代回收算法具有stop-the-world、垃圾回收过程并行和滑动压缩（sliding compaction）等特征。回收过程分为三个阶段：<br><br>第一阶段，每个年龄代分成固定大小的区域（regions）。在标记过程中，那些能够直接通过应用程序代码访问到的存活的Object划分给多个垃圾回收线程，这些线程并行的标记其它存活的对象。每当线程发现一个存活的对象，就会更新对象所在区域信息，记录这个对象所在位置和占用空间大小。<br><br>总结（summary）阶段是基于regions而不是对象。由于先前多次的压缩，因此留在每个年龄代左侧的部分数据的密度相对较大，包含了更多的存活的对象。对存活密度较大的区域进行压缩的消耗较大，并且不能释放多少有用的空间。所以，在summary阶段，首要的任务是确定每个区域的对象密度，从年龄代的最左侧开始，直到找到某个以区域满足其压缩释放的空间与压缩拷贝的代价相比更客观。从这一点开始，向左侧的区域被称为dense prefix，并且任何在dense prefix中的对象，在垃圾回收期间都不会移动。从这个点开始，向右侧的所有区域都将被压缩。需要注意的是，summary过程当前还是串行执行的；summary也可以并行执行，但是，即使是并行执行也不能提高多少效率。<br><br>在压缩过程中，回收线程使用summary过程中记录的数据确定哪些regions需要被填充，并且各个线程能够独立的将数据拷贝到对应的区域中。回收结束后，heap区一端是对象密度较大的区域，而另外一端是一个连续未被占用的空间。<h3 id="使用Parallel_Compacting_Collector的时机">使用Parallel Compacting Collector的时机</h3>
与Parallel Collector相似，Parallel Compacting Collector适合应用于多CPU的服务器上，由于老年代的并行回收，缩短了暂停时间（pause time），因此更适合用于对暂停时间有严格要求的应用。可以通过配置-XX:ParallelGCThreads=n的方式配置回收过程中，回收器使用的线程数目。<h3 id="使用Parallel_compaction_Collector">使用Parallel compaction Collector</h3>
可以通过指定命令行参数-XX:+UseParllelOldGC的方式显示指定使用Parallel Compaction Collector。<h2 id="Concurrent_Mark-Sweep(CMS)Collector">Concurrent Mark-Sweep(CMS)Collector</h2>
年轻代回收暂停的时间一般都很短暂，对于回收频率较低的老年代，可能需要较长时间的暂停，尤其是heap空间比较大的情况。有些应用相对于吞吐量来说，相应时间显得更重要，因此，HotSpot JVM提供了concurrent mark-sweep（CMS）回收器，或者称为低延时（low-latency）回收器。<h3 id="年轻代使用Parallel_Collector">年轻代使用Parallel Collector</h3>
CMS回收器年轻代使用Parallel相同的垃圾回收算法。<h3 id="老年代使用CMS算法">老年代使用CMS算法</h3>
CMS回收过程中，大多数时间都是与应用程序并行执行的。<br><br>CMS回收过程以一个短暂的暂停开始（称为initial mark），这个过程标注那些能够直接被应用程序直接访问到的初始对象集合。之后回收器并行标记那些通过初始对象集合能够访问到的其它对象。由于在并行标记过程中，应用程序并行运行，可能会更新对象的引用，为了解决这个问题，应用程序重新暂停，回收器重新访问那些在并行标记期间被更新的对象，重新标记他们，这个过程称为remark phase。remark phase可以是多个线程并行标记，因此与initial mark更高效。<br><br>remark phase结束后，heap中的所有存活的对象都已经被标记，接下来的并行清理过程（concurrent sweep phase)将会释放所有垃圾对象占用的空间。<br><br>由于CMS回收过程有一些操作，例如在remark过程中重新访问对象，增加了回收器的工作量，垃圾回收的代价也增加。因此，这也是那些希望缩短暂停时间的回收器需要权衡的问题。<br><br>CMS是唯一不压缩的垃圾回收器，也就是说，CMS垃圾回收结束后，并没有将对象移动到老年代的一端。<br><br>CMS舍去了压缩过程从而减少了垃圾回收过程的时间，但是不连续的内存空间，不能够使用单一指针形式分配内存，而是需要一些empty free列表记录可用空间。CMS维护一组empty list，将没有被占用的零散的内存空间链接起来，需要分配内存时，回收器查找到一个适当的list（依赖要分配的空间大小），这个list查找到一个足够大的内存空间分配给对象。CMS老年代中分配空间与bump-the-pointer模式相比代价要高很多，也正因此，CMS年轻代的回收时间也受到影响（因为大多数老年代中对象的分配是由于年轻代回收过程中对象晋级造成的）。<br><br>CMS垃圾回收第一次标注过程中，应用程序仍然可以在堆空间分配对象，老年代的空间占用仍然可以增长，因此，CMS垃圾回收与其他的回收算法相比需要更多的内存空间。尽管回收器能够保证所有存活对象能够正确保留下来，但是有一些对象在回收过程中变成垃圾，这些垃圾对象在下次垃圾回收前都不会被释放，他们成为漂浮垃圾（floating garbage）。<br><br>由于没有压缩，CMS回收后可能存在垃圾碎片，为了应对碎片，CMS跟踪对象分配的平均大小，预测对象需求的空间，并且合并或者拆分空闲空间满足需求。<br><br>与其他的垃圾回收算法不同，CMS并不是等到老年代空间已经满了才开始垃圾回收，而是，尝试在老年代空间耗尽之前完成垃圾回收。否则，CMS会回复到串行或者并行的垃圾回收算法，为了避免这种降级，CMS统计先前垃圾回收的时间间隔，预测下次回收的时间，并在预测时间到来时回收垃圾。CMS垃圾回收也可能在老年代空间占用比率超过设定值时启动。可以通过命令行参数-XX:CMSInitiationOccupancyFraction=n来设置，其中n表示占用比率，默认是68.<br><br>简单说，与并行回收相比，CMS降低了老年代回收的暂停时长（有时会很显著），代价是年轻代回收暂停时间略微变长、吞吐量可能会降低、需要更多的heap空间。<br><h3 id="incremental_model">incremental model</h3>
CMS的并行过程（concurrent phases）可以使用渐增（incrementally）方式执行。渐增方式通过周期性暂停并行过程，以便将处理器让出来给应用程序使用从而减轻并行回收过程长时间占用处理进程。并行过程回收任务被划分成多个小块时间任务，在年轻代回收过程中触发任务的执行。这种模式适用于运行于少量处理器（例如1或者2）并且对暂停时间有严格要求的应用中。<h3 id="适用CMS的时机">适用CMS的时机</h3>
CMS适用于对暂停时间有要求的，并且在垃圾回收过程中，能够和并行应用程序共享处理进程的应用（由于CMS回收过程中，会占用应用程序的cpu周期）。一般来说，老年代中有大量存活的对象并且运行在多核处理器上的应用程序，适用于CMS，最常见的例子如web 服务器。如果应用程序有暂停时间的限制，可以考虑使用CMS。CMS同样适用于老年代大小适当的单核处理器交互式应用程序。<br><h3 id="使用CMS">使用CMS</h3>
可以通过配置命令行参数-XX:UseConcMarkSweepGC参数来显示使用CMS。通过配置-XX:+CMSIncrementalMode来显示使用渐增式CMS。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://guanxinquan.github.io/blog/2014/07/10/gc/" data-id="5zbvm3ozkatzlaek" class="article-share-link">Share</a>
      
        <a href="http://guanxinquan.github.io/blog/2014/07/10/gc/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/blog/2014/06/17/lucene_FST_parser/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">lucene中的FST算法分析</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/算法/">算法</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/fst/">fst</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/生活/">生活</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/fst/" style="font-size: NaNpx;">fst</a><a href="/blog/tags/生活/" style="font-size: NaNpx;">生活</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/07">July 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/06">June 2014</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2014/07/10/gc/">(no title)</a>
          </li>
        
          <li>
            <a href="/blog/2014/06/17/lucene_FST_parser/">lucene中的FST算法分析</a>
          </li>
        
          <li>
            <a href="/blog/2014/06/17/firstblog/">青春纪念</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2014 xinquan.guan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog//" class="mobile-nav-link">Home</a>
  
    <a href="/blog//archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'httpguanxinquangithubio';
  
  var disqus_url = 'http://guanxinquan.github.io/blog/2014/07/10/gc/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//go.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/blog/js/script.js" type="text/javascript"></script>
  </div>
</body>
</html>