<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>java 虚拟机垃圾回收原理 | MR.GUAN</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Hotspot GC

垃圾回收的基本概念
垃圾回收器主要负责：

为对象分配内存；
确保可执行代码能够访问到的对象保留在内存中；
无法被可执行代码访问到的对象占用的空间得到释放。">
<meta property="og:type" content="article">
<meta property="og:title" content="java 虚拟机垃圾回收原理">
<meta property="og:url" content="http://guanxinquan.github.io/blog/blog/2014/07/10/gc/">
<meta property="og:site_name" content="MR.GUAN">
<meta property="og:description" content="Hotspot GC

垃圾回收的基本概念
垃圾回收器主要负责：

为对象分配内存；
确保可执行代码能够访问到的对象保留在内存中；
无法被可执行代码访问到的对象占用的空间得到释放。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java 虚拟机垃圾回收原理">
<meta name="twitter:description" content="Hotspot GC

垃圾回收的基本概念
垃圾回收器主要负责：

为对象分配内存；
确保可执行代码能够访问到的对象保留在内存中；
无法被可执行代码访问到的对象占用的空间得到释放。">
  
    <link rel="alternative" href="/atom.xml" title="MR.GUAN" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/blog/css/style.css" type="text/css">
  
</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog//" id="logo">MR.GUAN</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog//">Home</a>
        
          <a class="main-nav-link" href="/blog//archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="submit" value="&#xF002;" class="search-form-submit"><input type="hidden" name="q" value="site:http://guanxinquan.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-gc" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2014/07/10/gc/" class="article-date">
  <time datetime="2014-07-10T14:37:01.000Z" itemprop="datePublished">Jul 10 2014</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      java 虚拟机垃圾回收原理
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Hotspot_GC">Hotspot GC</h1>
<p><br></p>
<h1 id="垃圾回收的基本概念">垃圾回收的基本概念</h1>
<p>垃圾回收器主要负责：</p>
<ol>
<li>为对象分配内存；</li>
<li>确保可执行代码能够访问到的对象保留在内存中；</li>
<li>无法被可执行代码访问到的对象占用的空间得到释放。<br><a id="more"></a><h2 id="设计特性选择">设计特性选择</h2>
<h3 id="串行和并行">串行和并行</h3>
串行垃圾回收器，在同一时间段内，即使是多核处理器情况下，垃圾回收仅有一个线程在执行。并行垃圾回收器，在垃圾回收的过程中，任务被分解成多个部分，并且各部分任务能够并行执行在不同的cpu上。并行垃圾回收能够降低垃圾回收消耗的时间，代价是复杂的逻辑和潜在的内存碎片。<h3 id="同步（concurrent）和暂停（stop_the_world）">同步（concurrent）和暂停（stop the world）</h3>
stop-the-world方式垃圾回收期间，应用程序的运行被完全暂停，而concurrent方式的垃圾回收过程中，一个或多个垃圾回收任务可以同时与应用程序并行运行。通常来说，concurrent方式的垃圾回收的多数回收任务能够和应用程序并行执行，但是，也需要短暂的stop-the-world暂停。stop-the-world相对于concurrent来说要简单的多，在stop-the-world垃圾回收过程中，整个heap区都会被锁住，在垃圾回收过程中，不会有任何的对象修改，他的缺点在于，对于某些应用来说，不能接受较长时间的stop-the-world暂停。concurrent垃圾回收的暂停时间相对较短，但是需要处理在垃圾回收期间，有可能被应用程序修改或者更新的对象，这回影响垃圾回收的效率并需要更大的堆空间。<h3 id="压缩（compacting）、不压缩（no-compacting）和拷贝（copying）">压缩（compacting）、不压缩（no-compacting）和拷贝（copying）</h3>
垃圾回收器确定哪些对象是垃圾对象后，可以将所有的对象都移动到heap的一端，回收heap另一端的空间。compacting后，分配新的对象将变的容易，一个简单的指针指向下一个将要被分配的heap空间位置，新的对象仅需从这个指针位置起，划分出足够的空间即可。no-compacting垃圾回收器，不会将所有的live对象紧凑的排在heap的一端，而是会记录（in-place）被释放对象的位置，他的优点在于能够快速的完成垃圾回收，缺陷在于潜在的内存碎片。通常意义讲，no-compacting方式要比compacting方式的垃圾回收，在内存分配过程中会更耗时，因为，从in-place表中找到一个大小适中的空间比直接移动指针要更耗时间。第三种可选的垃圾回收器是coping，将所有live的对象都紧凑的拷贝到另外的内存区域。优点在于，原有空间（source）变成空的，能够简单、快速、有序的分配，缺点在于拷贝对象需要消耗一定的时间和额外的存储空间。<h2 id="按代（Generational）回收器">按代（Generational）回收器</h2>
generational回收将内存分成多个generations，每个generation都是一个单独存放不同年龄段（ages）的对象池。最常见的是分成两个年龄代，新生代和老年代。<br>不同的年龄代可以有不同的垃圾回收算法。按代回收算法是基于如下假说：<br><em>大多数分配的对象不会存活较长时间，他们在年轻代就死亡；
</em>少量的年轻的对象能够在老年代出现。<br><br>年轻代垃圾回收相对要更频繁、更有效、更快速，因为年轻代的存储空间较小，并且存放的多数都是短期对象。<br><br>那些经历过指定次数年轻代垃圾回收的对象将会被晋级到老年代中。老年代的存储空间一遍要远大于年轻代，并且，存储对象占用的空间增长缓慢，因此，老年代垃圾回收频率很低，并且消耗更长时间。<br><br>由于年轻代垃圾回收比较频繁，因此选择收算法更关注于回收速度，另一方面，老年代垃圾算法要更关注空间效率，因为老年代占用了heap区域的大部分空间，并且要在较低的垃圾密度下更好的工作。<h1 id="java_HotSpot_JVM_GC">java HotSpot JVM GC</h1>
<h2 id="HotSpot_按代回收">HotSpot 按代回收</h2>
HotSpot JVM的内存被分为三代，分别是年轻代，老年代和永久（permanent）代，大多数Objects在年轻代中初始化。老年代中存放着经历了指定次数年轻代垃圾回收后仍然存活的对象，以及一些占用空间比较大的对象，他们很可能直接创建在老年代中。持久区存放一些方便JVM查找垃圾回收管理的对象信息，例如classes或者methods的描述对象和classes和methods本身。<br><br>年轻代由一个伊甸园（Eden）区和两个存活（survivor）区组成，大多数对象都在Eden区初始化。（有一部分比较大的对象，很可能直接分配在老年代中）。survivor区存放至少经历一次年轻代垃圾回收仍然存活的对象，并且还存在一定几率在晋升到old区之前无效的对象。在任何一个时间内，仅有一个survivor区保存存活对象，另外一个一直是空的，直到下次垃圾回收。<h2 id="垃圾回收类型">垃圾回收类型</h2>
年轻代空间耗尽后，年轻代垃圾回收就会执行。当老年代或者永久代耗尽，full collection就会执行。在full gc的过程中，所有年龄代都会被回收，一般来讲，由于年轻代能够最高效的定位哪些是垃圾，因此最先执行，之后是老年代的垃圾回收算法会在老年代和永久代执行。如果，垃圾回收还需要compacting，那么不同的代间分别执行compacted。<br><br>有时，老年代太满了，已经无法继续分配年轻代晋级过来的对象，此时，年轻代垃圾回收将不会执行，而是将在整个heap区域执行老年代垃圾回收算法（CMS算法除外，因为CMS老年代算法无法回收年轻代的空间）。<h2 id="快速分配">快速分配</h2>
在很多情况下，内存中会有大量的连续的空间用于分配对象，此时，使用偏移指针（bump-the-pointer）分配对象会很高效。指针只需要跟踪先前最后一个对象分配位置的结尾处，当有新的对象分配请求到来时，仅需要验证当前代中剩余的空间是否能够容纳新对象，如果能够承载，仅需要更新指针并初始化对象即可。<br><br>对于多线程应用，分配过程需要保证线程安全。如果使用锁控制，在代中分配空间将会变成瓶颈，并且影响性能。HotSpot使用Thread-Local Allocation Buffers（TLABs）算法，通过使每个现成拥有自己的buffer（代中的一小块区间），提高了并行程序分配内存的吞吐率。由于每个TLAB块仅有一个线程可以访问，因此，通过bump-the-pointer技术能够快速分配内存。例如：管理TLABs平均要消耗1%的Eden，结合使用线性分配（bump-the-pointer）每次的内存分配仅需要大概10个本地指令就能完成。<h2 id="Serial_Collector">Serial Collector</h2>
Serial collector，年轻代或者老年代回收都是stop-the-world方式串行执行（仅用一个cpu），即是说，在垃圾回收期间，整个应用程序都是暂停的。<h3 id="年轻代的串行回收">年轻代的串行回收</h3>
下图描述了使用串行化的年轻代回收方式。在Eden中存活的对象被拷贝到空的survivor区域中（图中to标记的区域），那些很大的对象有可能直接拷贝到老年代中。在非空的survivor区域中存活的并且被认为依然很年轻的对象（图中from）也会被拷贝到另一个survivor中，那些被认为应该晋升为老年区的对象将会被直接拷贝到老年代中。<strong>如果To区域已经满了，那面Eden区或者From survivor区剩余的对象将会直接拷贝到老年代，无论对象已经经历了多少次的年轻代gc</strong><br><br>年轻代回收结束后，Eden区域和先前的survivor区域都变成空的，只有先前空的survivor空间保留存活的对象，survivor空间将会调换角色。<h3 id="老年代串行回收">老年代串行回收</h3>
串行老年代回收过程中，老年代和持久代使用mark-sweep-compact算法，在mark阶段，收集器确定哪些对象依然存活，在sweep阶段，定义垃圾对象，之后，收集器使用滑动压缩，将存活的object都向老年代起始位置滑动（持久代同理），将连续的空闲的空间留在代的末尾。compacting使得在老年代或者持久代中能够使用bump-the-pointer技术快速分配对象。<h3 id="使用窜行收集器的时机">使用窜行收集器的时机</h3>
串行收集器可以在多数客户端应用上或者对短暂停（stop-the-world的时间）要求不敏感的需求。<h3 id="使用串行收集器">使用串行收集器</h3>
在java5.0版本中，对于非server-class机器，串行收集器是默认的选择，在其他机器上，可以通过-XX:+UseSerialGC命令显示指定使用串行收集器。<h2 id="Parallel_Collector">Parallel Collector</h2>
<h3 id="年轻代的回收">年轻代的回收</h3>
Parallel Collector使用Serial Collector的回收算法，但却是并行的版本。Parallel Collector也是stop-the-world和coping回收器，但是他能够利用多cpu并发处理年轻代的垃圾回收，降低了垃圾回收的成本，提高了应用程序的吞吐率。<h3 id="老年代的回收">老年代的回收</h3>
老年代的回收使用与Serial Collector一样的算法，既mark-sweep-compact垃圾回收算法。<h3 id="Parallel_Collector使用时机">Parallel Collector使用时机</h3>
由于Parallel Collector存在频率较低，潜在stop-the-world时间较长的老年代回收，因此，他适用于执行在多cpu机器上并且没有严格的暂停时间长度的限制应用程序。例如，批处理程序、账单程序、科学计算等。<h3 id="使用Parallel_Collector垃圾收集器">使用Parallel Collector垃圾收集器</h3>
Parallel Collector是jase5.0默认的服务（server-class）机器配置垃圾收集器。在其他的情况下，可以通过显示配置-XX:+UseParallelGC命令配置并行垃圾收集。<h2 id="Parallel_Compacting_Collector">Parallel Compacting Collector</h2>
Parallel Compacting Collector出现在j2se5.0 update 6. Parallel Compacting Collector与Parallel Collector的区别在于，老年代回收算法的不同。需要注意的是，Parallel Compacting Collector会作为Parallel Collector的替代品存在。<h3 id="Parallel_Compacting_Collector_年轻代收集算法">Parallel Compacting Collector 年轻代收集算法</h3>
与Parallel Collector年轻代回收算法相同。<h3 id="Parallel_Compacting_Collector_老年代回收算法">Parallel Compacting Collector 老年代回收算法</h3>
Parallel Compacting Collector老年代和持久代回收算法具有stop-the-world、垃圾回收过程并行和滑动压缩（sliding compaction）等特征。回收过程分为三个阶段：<br><br>第一阶段，每个年龄代分成固定大小的区域（regions）。在标记过程中，那些能够直接通过应用程序代码访问到的存活的Object划分给多个垃圾回收线程，这些线程并行的标记其它存活的对象。每当线程发现一个存活的对象，就会更新对象所在区域信息，记录这个对象所在位置和占用空间大小。<br><br>总结（summary）阶段是基于regions而不是对象。由于先前多次的压缩，因此留在每个年龄代左侧的部分数据的密度相对较大，包含了更多的存活的对象。对存活密度较大的区域进行压缩的消耗较大，并且不能释放多少有用的空间。所以，在summary阶段，首要的任务是确定每个区域的对象密度，从年龄代的最左侧开始，直到找到某个以区域满足其压缩释放的空间与压缩拷贝的代价相比更客观。从这一点开始，向左侧的区域被称为dense prefix，并且任何在dense prefix中的对象，在垃圾回收期间都不会移动。从这个点开始，向右侧的所有区域都将被压缩。需要注意的是，summary过程当前还是串行执行的；summary也可以并行执行，但是，即使是并行执行也不能提高多少效率。<br><br>在压缩过程中，回收线程使用summary过程中记录的数据确定哪些regions需要被填充，并且各个线程能够独立的将数据拷贝到对应的区域中。回收结束后，heap区一端是对象密度较大的区域，而另外一端是一个连续未被占用的空间。<h3 id="使用Parallel_Compacting_Collector的时机">使用Parallel Compacting Collector的时机</h3>
与Parallel Collector相似，Parallel Compacting Collector适合应用于多CPU的服务器上，由于老年代的并行回收，缩短了暂停时间（pause time），因此更适合用于对暂停时间有严格要求的应用。可以通过配置-XX:ParallelGCThreads=n的方式配置回收过程中，回收器使用的线程数目。<h3 id="使用Parallel_compaction_Collector">使用Parallel compaction Collector</h3>
可以通过指定命令行参数-XX:+UseParllelOldGC的方式显示指定使用Parallel Compaction Collector。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://guanxinquan.github.io/blog/2014/07/10/gc/" data-id="pk0j78290orkei15" class="article-share-link">Share</a>
      
        <a href="http://guanxinquan.github.io/blog/2014/07/10/gc/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/blog/2014/06/17/lucene_FST_parser/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">lucene中的FST算法分析</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/算法/">算法</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/fst/">fst</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/生活/">生活</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/算法/">算法</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/fst/" style="font-size: NaNpx;">fst</a><a href="/blog/tags/生活/" style="font-size: NaNpx;">生活</a><a href="/blog/tags/算法/" style="font-size: NaNpx;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/07">July 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/06">June 2014</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2014/07/10/gc/">java 虚拟机垃圾回收原理</a>
          </li>
        
          <li>
            <a href="/blog/2014/06/17/lucene_FST_parser/">lucene中的FST算法分析</a>
          </li>
        
          <li>
            <a href="/blog/2014/06/17/firstblog/">青春纪念</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2014 xinquan.guan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog//" class="mobile-nav-link">Home</a>
  
    <a href="/blog//archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'httpguanxinquangithubio';
  
  var disqus_url = 'http://guanxinquan.github.io/blog/2014/07/10/gc/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//go.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/blog/js/script.js" type="text/javascript"></script>
  </div>
</body>
</html>