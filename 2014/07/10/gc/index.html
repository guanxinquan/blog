<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>java 虚拟机垃圾回收原理 | MR.GUAN</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="垃圾回收的基本概念
垃圾回收器主要负责：

为对象分配内存；
确保可执行代码能够访问到的对象保留在内存中；
无法被可执行代码访问到的对象占用的空间得到释放。">
<meta property="og:type" content="article">
<meta property="og:title" content="java 虚拟机垃圾回收原理">
<meta property="og:url" content="http://guanxinquan.github.io/blog/blog/2014/07/10/gc/">
<meta property="og:site_name" content="MR.GUAN">
<meta property="og:description" content="垃圾回收的基本概念
垃圾回收器主要负责：

为对象分配内存；
确保可执行代码能够访问到的对象保留在内存中；
无法被可执行代码访问到的对象占用的空间得到释放。">
<meta property="og:image" content="/blog/pic/gc/generational_garbage_collection.png">
<meta property="og:image" content="/blog/pic/gc/serial_gc.png">
<meta property="og:image" content="/blog/pic/gc/after_serial_gc.png">
<meta property="og:image" content="/blog/pic/gc/old_serial_gc.png">
<meta property="og:image" content="/blog/pic/gc/parallel_collector.png">
<meta property="og:image" content="/blog/pic/gc/cms_gc.png">
<meta property="og:image" content="/blog/pic/gc/cms_no_compactiong.png">
<meta property="og:image" content="/blog/pic/gc/gc_generation_virtual_space.gif">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java 虚拟机垃圾回收原理">
<meta name="twitter:description" content="垃圾回收的基本概念
垃圾回收器主要负责：

为对象分配内存；
确保可执行代码能够访问到的对象保留在内存中；
无法被可执行代码访问到的对象占用的空间得到释放。">
  
    <link rel="alternative" href="/atom.xml" title="MR.GUAN" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/blog/css/style.css" type="text/css">
  
</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog//" id="logo">MR.GUAN</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog//">Home</a>
        
          <a class="main-nav-link" href="/blog//archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="submit" value="&#xF002;" class="search-form-submit"><input type="hidden" name="q" value="site:http://guanxinquan.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-gc" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2014/07/10/gc/" class="article-date">
  <time datetime="2014-07-10T14:37:01.000Z" itemprop="datePublished">Jul 10 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/算法/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      java 虚拟机垃圾回收原理
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="垃圾回收的基本概念">垃圾回收的基本概念</h1>
<p>垃圾回收器主要负责：</p>
<ol>
<li>为对象分配内存；</li>
<li>确保可执行代码能够访问到的对象保留在内存中；</li>
<li>无法被可执行代码访问到的对象占用的空间得到释放。<br><a id="more"></a><h2 id="设计特性选择">设计特性选择</h2>
<h3 id="串行（Serial）和并行（Parallel）">串行（Serial）和并行（Parallel）</h3>
串行垃圾回收器，在同一时间段内，即使是多核处理器情况下，垃圾回收仅有一个线程在执行。并行垃圾回收器，在垃圾回收过程中，任务被分解成多个部分，并且各部分任务能够并行执行在不同的内核上。并行垃圾回收能够降低垃圾回收消耗的时间，代价是复杂的逻辑和潜在的内存碎片。<h3 id="同步（concurrent）和暂停（stop_the_world或pause_time）">同步（concurrent）和暂停（stop the world或pause time）</h3>
stop-the-world方式垃圾回收期间，应用程序运行被完全暂停（suspended），而concurrent方式垃圾回收过程，一个或多个垃圾回收任务可以同时与应用程序并行运行。通常来说，concurrent方式多数回收任务能够和应用程序并行执行，但是，也需要短暂的stop-the-world。stop-the-world相对于concurrent来说要简单的多，在stop-the-world垃圾回收过程中，整个heap区都会被锁住，不会有任何的对象修改，他的缺点在于，对于某些应用来说，不能接受较长时间的stop-the-world。concurrent垃圾回收的暂停时间相对较短，但是需要处理在垃圾回收期间，有可能被应用程序修改或者更新的对象，影响垃圾回收效率，并需要更大的堆空间。<h3 id="压缩（compacting）、不压缩（no-compacting）和拷贝（copying）">压缩（compacting）、不压缩（no-compacting）和拷贝（copying）</h3>
垃圾回收器确定所有存活（live）对象后，可以将他们移动到heap的一端，回收heap另一端。（<strong>注意，这里所说的压缩（compacting）是指，将存活的对象以滑动的方式移动到内存的一端，这样内存另一端会有连续较大的空间</strong>）compacting后，分配新对象将变的容易，回收器维护一个简单指针，指针指向下一个将要被分配的heap空间位置，当需要分配对象时，新的对象仅需从指针位置起，划分出足够空间即可。no-compacting垃圾回收器，不会将所有的live对象紧凑地排在heap的一端，而是会记录（in-place）被释放对象的位置，优点在于能够快速完成垃圾回收，缺陷在于潜在的内存碎片。通常意义讲，no-compacting方式要比compacting方式的垃圾回收，在对象分配过程中会更耗时，因为，从in-place表中找到一个大小适中的空间比直接移动指针要更耗时间。第三种可选垃圾回收器是coping，将所有live对象都紧凑的拷贝到另外的内存区域。优点在于，原有空间（source）变成空的，能够简单、快速、有序的分配新对象，缺点在于拷贝对象需要消耗一定的时间和额外的存储空间。<h2 id="按代（Generational）回收器">按代（Generational）回收器</h2>
generational回收将内存分成多个generations，每个generation都是一个单独存放不同年龄段（ages）的对象池。最常见的是分成两个年龄代，新生代和老年代。<br>不同的年龄代可以有不同的垃圾回收算法。按代回收算法是基于如下假说：</li>
</ol>
<ul>
<li>大多数对象不会存活较长时间，他们在年轻代就死亡了；</li>
<li>少量年轻对象能够在老年代出现。</li>
</ul>
<p><img src="/blog/pic/gc/generational_garbage_collection.png" alt="generation Collection"><br>年轻代垃圾回收相对要更频繁、更有效、更快速，因为年轻代的存储空间较小，并且存放的多数都是短期对象。<br><br>那些经历过预定次数年轻代垃圾回收的对象将会被晋级到老年代中。老年代的存储空间一般要远大于年轻代，并且，存储对象占用的空间增长缓慢，因此，老年代垃圾回收频率很低，并且消耗更长时间。<br><br>由于年轻代垃圾回收比较频繁，因此选择回收算法更关注于回收速度，另一方面，老年代占用了heap区域的大部分空间，并且要在较低的垃圾密度下更好的工作，因此更关注空间效率。</p>
<h1 id="java_HotSpot_JVM_GC">java HotSpot JVM GC</h1>
<h2 id="HotSpot_按代回收">HotSpot 按代回收</h2>
<p>HotSpot JVM heap区分为三代，分别是年轻代，老年代和永久（permanent）代，大多数对象在年轻代中初始化。老年代中存放着经历了指定次数年轻代垃圾回收后仍然存活的对象和一些占用较大存储空间的对象（他们很可能直接在老年代中初始化）。持久区存放JVM垃圾回收管理需要的对象信息，例如classes或者methods的描述对象和classes和methods本身。<br><br>年轻代由一个伊甸园（Eden）区和两个存活（survivor）区组成，大多数对象都在Eden区初始化。（有一部分比较大的对象，很可能直接分配在老年代中）。survivor区存放至少经历一次年轻代垃圾回收仍然存活尚未达到晋级老年代资格的对象。在应用程序运行期间，仅有一个survivor区保存对象，另外一个一直是空的，直到下次垃圾回收。</p>
<h2 id="垃圾回收类型">垃圾回收类型</h2>
<p>年轻代空间耗尽后，年轻代垃圾回收（minor collection）就会执行，老年代或者永久代耗尽，full collection（major collection）就会执行。full gc过程中，所有年龄代都会被回收，年轻代能够高效的定位垃圾，因此最先执行，之后老年代和永久代执行垃圾回收。如果，垃圾回收还需要compacting，那么不同的代间分别执行compacted。<br><br>有时，老年代太满了，已经无法为年轻代晋级的对象分配空间，此时，年轻代垃圾回收将不会执行，而是将在整个heap区域执行老年代垃圾回收算法（CMS算法除外，因为CMS老年代算法无法回收年轻代的空间）。</p>
<h2 id="快速分配">快速分配</h2>
<p>多数情况，内存有大量连续空间用于对象分配，此时，使用偏移指针（bump-the-pointer）分配对象会很高效。指针记录先前最后一个对象分配的位置，需要分配新对象时，仅需验证当前代中剩余空间是否能容纳新对象，如果能，仅需要更新指针并初始化对象即可。<br><br>多线程应用对象分配过程需要保证线程安全，如果使用锁控制，分配空间将会变成瓶颈，严重影响应用程序性能。HotSpot使用Thread-Local Allocation Buffers（TLABs）算法，每个线程拥有自己的buffer（代中的一小块区间），提高了并行程序分配内存的吞吐率。由于每个TLAB块仅有一个线程可以访问，因此，通过内部使用bump-the-pointer技术能够快速分配内存。例如：管理TLABs平均要消耗1%的Eden，结合使用线性分配（bump-the-pointer）每次的内存分配仅需要大概10个本地指令就能完成。</p>
<h2 id="Serial_Collector">Serial Collector</h2>
<p>Serial collector，年轻代或者老年代回收都是stop-the-world方式串行执行（仅用一个处理器），即是说，在垃圾回收期间，整个应用程序都是暂停的。</p>
<h3 id="年轻代的串行回收">年轻代的串行回收</h3>
<p>下图描述了串行年轻代回收过程。Eden区存活的对象被拷贝到空的survivor区域中（图中to标记的区域），很大的对象可能直接拷贝到老年代中。非空的survivor区域中（图中from标记的区域）存活尚不满足晋级老年代的对象也会被拷贝到另一个survivor中，满足晋级老年区的对象直接拷贝到老年代中。<strong>如果To区域已经满了，那面Eden区或者From survivor区剩余对象将直接拷贝到老年代，无论对象是否满足晋级条件</strong><br><br><img src="/blog/pic/gc/serial_gc.png" alt="Serial Young Collection"><br>年轻代回收结束后，Eden区域和先前非空survivor区域都变成空的，先前空的survivor空间保留存活对象，survivor空间将会调换角色，如下图。<br><img src="/blog/pic/gc/after_serial_gc.png" alt="After Serial Young Collection"></p>
<h3 id="老年代串行回收">老年代串行回收</h3>
<p>老年代（和持久代）串行回收使用mark-sweep-compact算法，在mark阶段，收集器标记存活对象，在sweep阶段，收集器使用滑动压缩，将存活的对象向老年代起始位置滑动（持久代同理），将连续的空闲的空间留在代的末端。compacting能够保证老年代或者持久代中能够使用bump-the-pointer技术快速分配对象。<br><img src="/blog/pic/gc/old_serial_gc.png" alt="Serial Old Collection"></p>
<h3 id="Serial_Collector使用时机">Serial Collector使用时机</h3>
<p>串行收集器可以在多数客户端应用上或者对暂停时间（stop-the-world的时间）要求不敏感的应用中使用。</p>
<h3 id="使用Serial_Collector">使用Serial Collector</h3>
<p>在java5.0版本中，对于非server-class机器，串行收集器是默认的选择，在其他机器上，可以通过-XX:+UseSerialGC命令显示指定使用串行收集器。</p>
<h2 id="Parallel_Collector">Parallel Collector</h2>
<h3 id="年轻代的回收">年轻代的回收</h3>
<p>Parallel Collector使用Serial Collector的回收算法，但却是并行的版本。Parallel Collector也是stop-the-world和coping回收器，但是他能够利用多cpu并发处理年轻代垃圾回收，降低垃圾回收成本，提高应用程序吞吐率。<br><img src="/blog/pic/gc/parallel_collector.png" alt="Parallel Collector"></p>
<h3 id="老年代的回收">老年代的回收</h3>
<p>老年代回收使用与Serial Collector一样的算法，既mark-sweep-compact垃圾回收算法。</p>
<h3 id="Parallel_Collector使用时机">Parallel Collector使用时机</h3>
<p>由于Parallel Collector存在频率较低，潜在stop-the-world时间较长的老年代回收，因此，他适用于执行在多cpu机器上并且没有严格的暂停时间限制应用程序。例如，批处理程序、账单程序、科学计算等。</p>
<h3 id="使用Parallel_Collector">使用Parallel Collector</h3>
<p>Parallel Collector是jase5.0默认的服务（server-class）机器配置垃圾收集器。在其他的情况下，可以通过显示配置-XX:+UseParallelGC命令配置Parallel Collector。</p>
<h2 id="Parallel_Compacting_Collector">Parallel Compacting Collector</h2>
<p>Parallel Compacting Collector出现在j2se5.0 update 6. Parallel Compacting Collector与Parallel Collector的区别在于，老年代回收算法。需要注意的是，Parallel Compacting Collector会作为Parallel Collector的替代品存在。</p>
<h3 id="Parallel_Compacting_Collector_年轻代收集算法">Parallel Compacting Collector 年轻代收集算法</h3>
<p>与Parallel Collector年轻代回收算法相同。</p>
<h3 id="Parallel_Compacting_Collector_老年代回收算法">Parallel Compacting Collector 老年代回收算法</h3>
<p>Parallel Compacting Collector回收算法具有stop-the-world、并行回收和滑动压缩（sliding compaction）等特征。回收过程分为三个阶段：<br><br>第一阶段标记（mark）：标记过程，老年代（或者持久代）分成固定大小的区域（regions），能够直接通过应用程序代码访问到的存活对象划分给多个垃圾回收线程，这些线程并行标记其它存活对象。每当线程发现一个存活的对象，就会更新对象所在区域信息，记录这个对象所在位置和占用空间大小。<br><br>第二阶段总结（summary）：summary阶段是基于regions而不是对象。由于先前多次的压缩，因此留在每个年龄代左侧部分数据的密度相对较大，包含了更多存活的对象。对存活密度较大区域进行压缩的消耗较大，并且不能释放多少有用的空间。所以，在summary阶段，首要任务是确定每个区域的对象密度，从年龄代最左侧开始，直到找到某个区域满足其压缩释放空间与压缩拷贝代价相比更有价值。从这一点开始，向左的区域被称为dense prefix，并且任何在dense prefix中的对象，在垃圾回收期间都不会移动。从这个点开始，向右的所有区域都将被压缩。需要注意的是，summary过程当前还是串行执行的；summary也可以并行执行，但是，即使是并行执行也不能提高多少效率。<br><br>第三阶段压缩: 在压缩过程中，回收线程使用summary过程中记录的数据确定哪些regions需要被填充，并且各个线程能够独立的将数据拷贝到对应的区域中。回收结束后，heap区一端是对象密度较大的区域，而另外一端是一个连续未被占用的空间。</p>
<h3 id="使用Parallel_Compacting_Collector的时机">使用Parallel Compacting Collector的时机</h3>
<p>与Parallel Collector相似，Parallel Compacting Collector适合应用于多CPU的服务器上，由于老年代的并行回收，缩短了暂停时间（pause time），因此更适合用于对暂停时间有严格要求的应用。可以通过配置-XX:ParallelGCThreads=n的方式配置回收器使用的线程数目。</p>
<h3 id="使用Parallel_compaction_Collector">使用Parallel compaction Collector</h3>
<p>可以通过指定命令行参数-XX:+UseParllelOldGC的方式显示指定使用Parallel Compaction Collector。</p>
<h2 id="Concurrent_Mark-Sweep(CMS)Collector">Concurrent Mark-Sweep(CMS)Collector</h2>
<p>年轻代回收暂停时间一般很短暂，对于回收频率较低的老年代，可能需要较长时间的暂停，尤其是heap空间比较大的情况。有些应用相对于吞吐量来说，暂停时间显得更重要，因此，HotSpot JVM提供了concurrent mark-sweep（CMS）回收器，或者称为低延时（low-latency）回收器。</p>
<h3 id="年轻代使用Parallel_Collector">年轻代使用Parallel Collector</h3>
<p>CMS回收器年轻代使用Parallel相同的垃圾回收算法。</p>
<h3 id="老年代使用CMS算法">老年代使用CMS算法</h3>
<p>CMS回收过程的大多数时间都是与应用程序并行执行的。<br><br>CMS回收过程以一个短暂的暂停开始（称为initial mark），initial mark标注直接能被应用程序访问的初始对象。随后回收器并行标记通过初始对象能访问的对象。在并行标记过程中，应用程序并行运行，可能会更新对象的引用，为了解决这个问题，应用程序重新暂停，回收器重新访问那些在并行标记期间被更新的对象，重新标记他们，这个过程称为remark phase。remark phase可以是多个线程并行标记，因此比initial mark更高效。<br><br>remark phase结束后，heap中所有存活对象都已经被标记，随后并行清理过程（concurrent sweep phase)将会释放所有垃圾对象占用的空间。<br><br><img src="/blog/pic/gc/cms_gc.png" alt="CMS Collector"><br>由于CMS回收过程有一些操作，例如remark过程中重新访问对象，增加回收器的工作量，垃圾回收代价也随之增加。因此，这也是那些希望缩短暂停时间的回收器需要权衡的问题。<br><br>CMS是hotSpot唯一不压缩的垃圾回收器，CMS垃圾回收结束后，并没有将对象移动到老年代的一端。<br><br><img src="/blog/pic/gc/cms_no_compactiong.png" alt="CMS no compaction"><br>CMS舍去压缩过程，缩短回收过程的暂停时间，但不连续的内存空间，不能使用单一指针形式分配内存，需要一组empty free列表记录可用空间。CMS维护一组empty list，将没有被占用零散的内存空间链接起来，分配内存时，回收器查找一个适当的list（依赖分配的空间大小），从list中查找一个足够大的内存空间分配给对象。CMS老年代分配空间与bump-the-pointer模式相比代价要高很多，也正因此，CMS年轻代的回收时间也受到影响（因为大多数老年代中对象的分配是由年轻代回收过程中对象晋级造成的）。<br><br>并行标注过程中，应用程序仍然可以在堆空间分配对象，老年代的空间占用仍然可以增长，因此，CMS垃圾回收与其他的回收算法相比需要更多的内存空间。尽管回收器能够保证所有存活对象正确保留下来，但是有一些对象在回收过程中变成垃圾，这些垃圾对象在下次垃圾回收前都不会被释放，他们成为漂浮垃圾（floating garbage）。<br><br>由于没有压缩，CMS回收后可能存在垃圾碎片，为了应对碎片，CMS跟踪对象分配的平均大小，预测对象需求的空间，并且合并或者拆分空闲空间满足需求。<br><br>与其他的垃圾回收算法不同，CMS在老年代空间耗尽前开始垃圾回收。在回收过程中，老年代如果已经耗尽，CMS会退化为串行或者并行垃圾回收算法，为了避免这种退化，CMS统计先前垃圾回收的时间间隔，预测下次回收的时间，并在预测时间到来时回收垃圾。CMS垃圾回收也可能在老年代空间占用比率超过设定值时启动。可以通过命令行参数-XX:CMSInitiationOccupancyFraction=n来设置，其中n表示占用比率，默认是68.<br><br>简单说，与并行回收相比，CMS降低老年代回收的暂停时长（有时会很显著），代价是年轻代回收暂停时间略微变长、吞吐量可能会降低、需要更多的heap空间。<br></p>
<h3 id="incremental_model">incremental model</h3>
<p>CMS的并行标记过程（concurrent phases）可以使用渐增（incrementally）方式执行。渐增方式通过周期性暂停并行过程，以便将处理器让出来给应用程序使用，从而减轻并行回收过程长时间占用处理进程。并行过程回收任务被划分成多个小块时间任务，在年轻代回收过程中触发任务执行。这种模式适用于运行于少量处理器（例如1或者2）并且对暂停时间有严格要求的应用中。</p>
<h3 id="适用CMS的时机">适用CMS的时机</h3>
<p>CMS适用于对暂停时间有要求的，并且在垃圾回收过程中，能够和并行应用程序共享处理进程的应用（由于CMS回收过程中，会占用应用程序的cpu周期）。一般来说，老年代中有大量存活的对象，并且运行在多核处理器上的应用程序，适用于CMS，最常见的例子如web 服务器。如果应用程序有暂停时间限制，可以考虑使用CMS。CMS同样适用于老年代大小适当的单核处理器交互式应用程序。<br></p>
<h3 id="使用CMS">使用CMS</h3>
<p>可以通过配置命令行参数-XX:UseConcMarkSweepGC参数来显示使用CMS。通过配置-XX:+CMSIncrementalMode来显示使用渐增式CMS。</p>
<h1 id="虚拟机调优">虚拟机调优</h1>
<h2 id="代空间大小（sizing_of_generations）">代空间大小（sizing of generations）</h2>
<p>虚拟机提供一些参数，用于控制代空间大小和代间比例。在了解详情之前需要理解两个概念，提交空间（committed space）和虚拟空间（virtual space）。虚拟机初始化时，整个堆空间被预留出来，可以通过-Xmx（最大heap使用空间）参数调整预留堆空间大小。如果-Xms参数指定的起始heap空间小于-Xmx指定的最大heap空间，那么并不是所有的预留空间都立刻提交到虚拟机实际分配内存资源。如图，没有提交分配内存的预留空间称为virtual space。heap区的不同代（持久代、老年代或者年轻代）根据需求在执行过程中继续申请分配内存空间，直到virtual space耗尽，代空间就不能再继续申请更多的内存空间。<br><img src="/blog/pic/gc/gc_generation_virtual_space.gif" alt="gc generation virtual space"></p>
<h3 id="heap总大小">heap总大小</h3>
<h4 id="非Parallel_Collector_heap总大小">非Parallel Collector heap总大小</h4>
<p>对于非并行收集器（并行收集器在下小节讨论），默认情况下，每次垃圾回收都会调整heap区的大小（heap区指实际分配内存的部分，不包括virtual space），使得空闲和占用空间的比值在一定区间范围之内。主要受到-XX:MinHeapFreeRatio=<minimum>、-XX:MaxHeapFreeRatio=<maximum>、-Xms<min>和-Xmx<max>，几个参数控制，默认的32位solaris系统参数如下：</max></min></maximum></minimum></p>
<table><tr><td>parameter</td><td>Default Value</td></tr><tr><td>MinHeapFreeRatio</td><td>40</td></tr><tr><td>MaxHeapFreeRatio</td><td>70</td></tr><tr><td>-Xms</td><td>3670k</td></tr><tr><td>-Xmx</td><td>64m</td></tr></table>

<p>根据这些参数的值，如果回收后空闲空间的比值低于40%，当前代需要扩充空间到能够保持空闲空间高于40%，除非到达代的最大空间；同理，如果空闲空间超过70%，当前代的空间就会缩小，保证空闲空间不超过70%，除非到达当前代的最小值。<br><br>这些默认设置，对于大型的应用可能存在两个主要问题，其一，初始的heap空间太小，服务启动时需要经历多次full gc，并且不断调节heap区大小，导致服务启动缓慢；其二，默认最大heap太小，不适合大型的应用。下面给出指导意见：</p>
<ol>
<li>除非web应用由于较长的pause时间而无法满足需求，否者，尽量分配更多的内存空间给虚拟机，默认的64MB太小；</li>
<li>根据预期将-Xms和-Xmx设置为相同的值，避免虚拟机调整heap区的大小，缺点在于如果预测失误，虚拟机无法挽回过失（主要是heap占用了大量的无需被暂用的内存）；</li>
<li>通常，应用程序服务器处理核心越多，对应分配的heap空间应当越大，因为垃圾回收可以并行执行。</li>
</ol>
<h4 id="并行heap区大小">并行heap区大小</h4>
<p>j2se5.0为并行垃圾回收提供了新的调优方式，通过命令行参数的形式，设置对回收器期望的最大暂停时间和吞吐量，让jvm自动调节heap区间的大小。</p>
<h5 id="期望时间">期望时间</h5>
<p>通过如下命令行配置最大暂停时间<br><br>     —XX:MaxGCPauseMillis=n<br>此参数作为并行回收器的一个提示，期望的垃圾回收暂停时间要小于或者等于n。并行回收器会调整heap区的大小和其他的一些垃圾回收相关的参数，尽量保证垃圾回收暂停时间小于n毫秒。这些调整可能会影响到应用的吞吐量，有时甚至无法满足预设的期望暂停时间要求。<br><br>期望最大暂停时间应用于所有年龄代中。通常，如果期望时间没有满足，回收器会缩小当前年龄代空间试图去满足目标。期望最大暂停时间没有默认值。</p>
<h5 id="期望吞吐量">期望吞吐量</h5>
<p>吞吐量定义为jvm处理垃圾回收所用时间与非垃圾回收所用时间（应用程序时间）的比值。可以通过命令行设置最小吞吐量<br>     —XX:GCTimeRatio=n<br>垃圾回收时间和应用时间的比值为<br>    1/(1+n)<br>例如-XX:GCTimeRatio=19,垃圾回收时间占总时间的比为5%。默认n=99（即1%的时间用于垃圾回收）。垃圾回收时间是所有年龄代垃圾回收的总时间。如果回收器无法满足期望吞吐量，会增大代内的空间大小，从而增大两次垃圾回收间的应用运行时间，大的空间需要更长时间才能够填满。</p>
<h5 id="内存目标">内存目标</h5>
<p>如果期望吞吐和期望最大暂停时间都满足，垃圾回收器会逐渐缩小heap区的大小，直到其中一个期望值无法满足（一般来说是吞吐量目标）。</p>
<h5 id="期望优先级">期望优先级</h5>
<p>并行垃圾回收器先尝试满足期望最大暂停时间，只有期望时间满足后才尝试满足吞吐目标，同理，仅在上述两个目标都满足的情况下，才尝试满足内存目标。</p>
<h3 id="年轻代大小">年轻代大小</h3>
<p>确定heap总大小后，年轻代大小是性能优化的一个关键。年轻代占用heap的比重越大，minor垃圾回收的频率就越低，由于heap总的空间有限，因此年轻代占用越大，老年代占用的空间就越小，full gc的频率就越高。具体的比率需要考虑应用程序对象的生命周期长度的分布。<br>默认情况下，年轻代大小通过NewRatio参数控制。例如，-XX:NewRatio=3，那面年轻代与老年代的空间比就是1:3，换句话说，eden区和survivor区域大小的和为总内存空间的四分之一。<br>NewSize和MaxNewSize定义了年轻代空间的最小值和最大值，如果这两个参数取值相同，与将-Xms和-Xmx设置相同值固定整个heap区大小相似，将NewSize和MaxNewSize设置为相同值与通过设置一个整数倍数的NewRatio相比，能够更精细调节年轻代空间大小。</p>
<h4 id="survivor区域大小">survivor区域大小</h4>
<p>如果需要的话，通过SurvivorRatio参数控制survivor区域大小，但是它对性能调优效果并不明显。例如，设置-XX:SurvivorRation=6, survivor与Eden暂用比为1:6，换句话说，每个survivor空间是Eden空间的六分之一，或者是整个年轻代空间的八分之一。<br><br>survivor占用的空间太小，gc将多余的数据直接拷贝到持久代，如果survivor占用空间太大，大部分的空间都是未被使用。每一个gc都会选着一个阈值，用于控制对象在晋升为老年代前拷贝的次数。这个阈值一般是控制回收后保持survivor空间半满状态。命令行-XX:+PrintTenuringDistribution可以输出这个阈值和在年轻代空间中对象的年龄。同时这个参数对于观察对象年龄代的分布情况也很有用。<br>下表中给出32位系统中的默认参数值：<br></p>
<p><table><tr><td>Parameter</td><td>clinet jvm</td><td>server jvm</td></tr><tr><td>NewRatio</td><td>8</td><td>2</td></tr><tr><td>NewSize</td><td>2228K</td><td>2228k</td></tr><tr><td>MaxNewSize</td><td>not limited</td><td>not limited</td></tr><tr><td>survivorRatio</td><td>32</td><td>32</td></tr></table><br>MaxNewSize如果没有明确设定，这个值可以通过虚拟机可暂用的总内存空间和NewRatio两个值计算所得。</p>
<p>下面对服务端空间配置建议：</p>
<ol>
<li>首先要计算能够提供给虚拟机的最大内存空间，之后通过渐进方式调节年轻代空间的大小，找到最好的性能比例（需要注意，最大的堆空间大小应当小于实际内存空间大小，以避免过多的内存页面访问失败和抖动）。</li>
<li>当Xmx确定后，逐渐地缩小老年代空间的大小，增加年轻代空间大小。最后保证老年代有足够的空间保存应用程序需要访问的对象，并且为老年代额外预留10%-20%（或者更多）的空间。</li>
<li>年轻代需要分配足够的内存空间，当有更多的处理核心时，应该加大年轻代的占用空间，因为回收可以并行执行。</li>
</ol>
<h4 id="permanent区域大小">permanent区域大小</h4>
<p>对于大多数应用程序来说，持久区对垃圾回收的性能影响并不显著，但是某些特殊的应用程序，例如需要动态生成代码或者加载很多类的情况，比如说，某些jsp应用需要更大的持久区空间，可以通过-XX:MaxPermSize设置持久区空间大小。</p>
<h2 id="虚拟机默认选择和调优">虚拟机默认选择和调优</h2>
<p>在j2se5.0中，默认情况下，java虚拟机根据应用程序运行的操作环境决定垃圾回收器的种类（算法）、堆栈空间的大小以及运行方式（client或者server）。虚拟机的默认选择能够满足大部分应用的需求，相对于先前的虚拟机，启动时可以使用更少的参数。</p>
<h2 id="自动选择回收算法、heap大小和运行方式">自动选择回收算法、heap大小和运行方式</h2>
<p>server-class主机被定义为满足如下条件<br></p>
<ul>
<li>多于两个的物理内核</li>
<li>多于2GB的物理内存<br><br>除了32-bit的windows系统外，上述的定义被应用于所有其它系统平台。<br><br>不满足server-class主机默认的JVM value、垃圾回收器和heap大小如下：</li>
<li>client JVM</li>
<li>使用串行（Serial）垃圾回收器</li>
<li>初始的heap大小是4MB</li>
<li>最大的heap大小是64MB</li>
</ul>
<p>在server-class主机平台上，除非通过添加命令行参数-client，显示指定使用client jvm的形式启动外，都会以server jvm的形式启动虚拟机，默认的server jvm使用并行（Parallel）垃圾回收器。<br><br>在server-class的主机平台上，（client或者server形式）并且使用并行垃圾回收器，默认的初始和最大heap大小如下：</p>
<ul>
<li>初始大小为物理内存的1/64到1GB。（注意，由于server-class服务器被定义为至少有2GB的物理内存空间，因此最小的初始内存大小为32MB）</li>
<li>最大的heap大小为1/4物理大小到1GB。</li>
</ul>
<h1 id="建议">建议</h1>
<p>正如前面提到的，jvm能够根据环境自动选择垃圾回收算法、虚拟机启动的类型、heap配置，对大多数应用来说这些已经足够了。对垃圾回收器配置的最初建议为什么都不做，让系统根据应用运行的操作系统和硬件环境自动选择！之后测试应用程序，如果他具有较高的吞吐率和较低的暂停时间，那么，根本不用配置任何垃圾回收选项。<br><br>另一方面，如果应用程序因为垃圾回收纯在性能问题，首先综合系统和应用的特点，判断默认的垃圾回收方式是否纯在问题，如果纯在问题，选着适合的回收算法，查看性能是否满足需求。<br><br>可以使用一些工具来测试应用程序的性能，基于测试结果，可以对垃圾回收相关的选项进行调节，例如那些控制heap大小和回收行为的参数。需要注意：最好的gc调优方法为，先衡量（Measure）后调整。不要过度调优，由于应用程序的数据、硬件环境包括虚拟机算法都可能随着时间变化。</p>
<h1 id="OutOfMemoryError">OutOfMemoryError</h1>
<p>java.lang.OutOfMemmoryError是一个常见的导致应用程序自动退出的异常，当回收器没有足够的空间分配新的对象时，抛出这个异常。OutOfMemoryError并不意味着一定是应用程序内存泄露，也可能是由于回收器配置原因，例如，被指定的（或者默认分配的）堆区大小并不能满足应用程序的实际需求。<br>分析OutOfMemmoryError产生的原因时，要注意回收器提供的额外信息，下面列举了附加信息和对应可能导致OutOfMemmoryError的原因：</p>
<ul>
<li>Java heap space 。这个提示表明，回收器没有足够的空间分配新的对象，多数情况下，是由于通过显示指定-Xmx或者默认选取的堆最大空间不能满足应用程序的实际需求引起的。也可能是由于，应用程序持有大量的无用对象，这些对象不能够被垃圾回收器直接回收，可以使用HAT分析所有存活对象和对象之间引用关系。此外，如果应用程序中大量使用finalizers，导致大量线程调用finalizers，这些线程排队等待处理的速度如果跟不上finalizers需求产生的速度，回收器也会抛出OutOfMemmoryError异常，可以使用jconsole分析器监控等待执行finalization的对象数量。</li>
<li>PermGen space 。 回收器使用Perm区存储JMV的元数据，如果应用程序加载大量的classes，很可能导致Perm区消耗殆尽，可以使用-XX:MaxPermSize=n的方式指定Perm区大小。</li>
<li>Requested array size exceeds VM limit 。 如果应用程序试图分配一个数组的空间大于heap区的大小，将会抛出此异常。</li>
</ul>
<h1 id="gc的常用工具">gc的常用工具</h1>
<h3 id="-XX:+PrintGCDetails">-XX:+PrintGCDetails</h3>
<p>配置JVM启动选项-XX:+PrintGCDetails，回收器在每次垃圾回收后会打印回收信息，例如回收前后不同代间的存活对象的数量，每个年龄代可用内存空间，以及本次垃圾回收所用的时间。</p>
<h3 id="-XX:PrintGCTimeStamps">-XX:PrintGCTimeStamps</h3>
<p>这个配置选项是配合-XX:+PrintGCDetails选项一起使用的，能够额外打印出每次gc开始的时间。</p>
<h3 id="jmap">jmap</h3>
<p>jmap是基于Solaris或Linux系统JDK附带分析工具，能够打印出内存使用相关的统计和核心文件信息。<br><br>-heap选项，获取垃圾回收器的名字信息、算法参数详情（例如，并行垃圾回收器使用的并行回收线程的数目），heap区配和使用信息。<br><br>-histo选项，获取heap中的对象类信息。对于每个class，打印出heap中对应对象的数目，这些对象在内存中占用的空间和完整的类名信息，有助于分析内存是如何被使用的。<br><br>-permstat选项，某些需要加载大量类或者动态生成代码的应用程序（例如 Web服务器），指定一个适当的perm区大小显得很重要。如果应用程序加载了太多的类，JVM就会抛出OutOfMemmoryError异常。-permstat选项能够获得perm区对象统计信息，帮助诊断错误。</p>
<h3 id="jstat">jstat</h3>
<p>jstat工具使用HotSpot JVM的内部指令获取运行时应用程序的性能和资源消耗信息。有很多可用选项能够打印出垃圾回收器统计信息、各年龄代的容量和占用信息。</p>
<h1 id="垃圾回收的关键选项">垃圾回收的关键选项</h1>
<h2 id="垃圾回收器的选择">垃圾回收器的选择</h2>
<p>-XX:+UseSerialGC<br><br>-XX:+UseParallelGC<br><br>-XX:+UseParllelOldGC<br><br>-XX:+UseConcMarkSweepGC</p>
<h2 id="统计相关配置选项">统计相关配置选项</h2>
<p>-XX:+PrintGC<br><br>-XX:+PrintGCDetails<br><br>-XX:PrintGCTimeStamps</p>
<h2 id="Heap和年龄代大小选项">Heap和年龄代大小选项</h2>
<p>-Xmsn<br><br>-Xmxn<br><br>-XX:NewSize=n (默认初始年轻代空间大小bytes）<br><br>-XX:NewRatio=n (年轻代和老年代占用的空间比值，例如n=3，那么年轻代（包括Eden和两个Surivivor）占用的空间将是年轻代加上老年代占用空间的1/4,默认client JVM n=2，Server JVM n=8）<br><br>-XX:SurvivorRatio=n(Surivivor区与Eden区占用的空间比值，例如n=7，那么每个Survivor占用的空间将是年轻代的1/9，默认n=32)<br><br>-XX:MaxPermSize=n</p>
<h3 id="并行垃圾回收参数">并行垃圾回收参数</h3>
<p>-XX:ParallelGCThreads=n (垃圾回收的线程数，默认为cpu的内核数）<br><br>-XX:MaxGCPauseMillis=n （垃圾回收器期望的暂停时间（毫秒），无默认值）。<br><br>-XX:GCTimeRatio=n (1/(1+n)的时间将被用于垃圾回收，默认为99）。</p>
<h3 id="CMS参数">CMS参数</h3>
<p>-XX:+CMSIncrementalModel<br><br>-XX:+CMSIncrementalPacing<br><br>-XX:ParallelGCThreads=n<br></p>
<h1 id="附录">附录</h1>
<h2 id="Garbage_Collection_Roots">Garbage Collection Roots</h2>
<p>JVM能够直接访问的，定义在heap之外的Objects成为Garbage Collection Roots，可能是由下面情况产生：</p>
<ul>
<li>System class<br>由bootstrap/System类加载器加载的类实例，例如从rt.jar中加载的java.util.*</li>
<li>JNI Local<br>本地代码定义的局部变量（本地代码指：用户自定义JNI代码或者JVM内部定义代码）。</li>
<li>JNI Global<br>本地代码定义的全局变量。</li>
<li>Thread Block<br>当前活动线程块引用的对象。</li>
<li>Trhead<br>开始执行的，尚未终止的进程。</li>
<li>Busy Monitor<br>所有调用了wait()或者notify()或者synchronized的方法或者对象。例如调用synchronized(Object)或者进入synchronized的方法。静态方法意味着类实例，no-static方法意味着对象实例。</li>
<li>Java Local<br>本地变量，例如线程栈中方法的传入参数和创建的局部变量。</li>
<li>Native Stack<br>本地代码传入和传出的参数。很多函数有本地代码部分，那些传入到本地代码的参数将会被转换成GC Roots。例如文件、网络IO或者反射的参数。</li>
<li>Finalizable<br>排在队列中等待执行finalizer方法的对象。</li>
<li>Unfinalized<br>有finalizer方法，但是尚未在finalizer队列中等待finalized的对象。</li>
</ul>
<h1 id="参考文献">参考文献</h1>
<ol>
<li>Memory Management in the Java HotSpot™ Virtual Machine</li>
<li><a href="http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://guanxinquan.github.io/blog/2014/07/10/gc/" data-id="t5jeopvqkbq2h1pe" class="article-share-link">Share</a>
      
        <a href="http://guanxinquan.github.io/blog/2014/07/10/gc/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/gc/">gc</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/blog/2014/06/17/lucene_FST_parser/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">lucene中的FST算法分析</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/算法/">算法</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/fst/">fst</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/gc/">gc</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/生活/">生活</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/fst/" style="font-size: NaNpx;">fst</a><a href="/blog/tags/gc/" style="font-size: NaNpx;">gc</a><a href="/blog/tags/生活/" style="font-size: NaNpx;">生活</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/07">July 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/06">June 2014</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2014/07/10/gc/">java 虚拟机垃圾回收原理</a>
          </li>
        
          <li>
            <a href="/blog/2014/06/17/lucene_FST_parser/">lucene中的FST算法分析</a>
          </li>
        
          <li>
            <a href="/blog/2014/06/17/firstblog/">青春纪念</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2014 xinquan.guan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog//" class="mobile-nav-link">Home</a>
  
    <a href="/blog//archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'httpguanxinquangithubio';
  
  var disqus_url = 'http://guanxinquan.github.io/blog/2014/07/10/gc/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//go.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/blog/js/script.js" type="text/javascript"></script>
  </div>
</body>
</html>