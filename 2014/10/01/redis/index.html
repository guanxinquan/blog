<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>redis 算法研究 | MR.GUAN</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1. Redis key和value的存储形式
1.1. 基本数据结构
redis中使用hashmap存储key和对应的value。hashmap的定义如下：
typedef struct dict {
    dictType *type;
    void *privdata;
    dictht ht[2];
    long rehashidx; /* rehashing not in">
<meta property="og:type" content="article">
<meta property="og:title" content="redis 算法研究">
<meta property="og:url" content="http://guanxinquan.github.io/blog/blog/2014/10/01/redis/">
<meta property="og:site_name" content="MR.GUAN">
<meta property="og:description" content="1. Redis key和value的存储形式
1.1. 基本数据结构
redis中使用hashmap存储key和对应的value。hashmap的定义如下：
typedef struct dict {
    dictType *type;
    void *privdata;
    dictht ht[2];
    long rehashidx; /* rehashing not in">
<meta property="og:image" content="/blog/pic/redis/redis_table.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="redis 算法研究">
<meta name="twitter:description" content="1. Redis key和value的存储形式
1.1. 基本数据结构
redis中使用hashmap存储key和对应的value。hashmap的定义如下：
typedef struct dict {
    dictType *type;
    void *privdata;
    dictht ht[2];
    long rehashidx; /* rehashing not in">
  
    <link rel="alternative" href="/atom.xml" title="MR.GUAN" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/blog/css/style.css" type="text/css">
  
</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog//" id="logo">MR.GUAN</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog//">Home</a>
        
          <a class="main-nav-link" href="/blog//archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="submit" value="&#xF002;" class="search-form-submit"><input type="hidden" name="q" value="site:http://guanxinquan.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-redis" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2014/10/01/redis/" class="article-date">
  <time datetime="2014-10-01T04:45:00.000Z" itemprop="datePublished">Oct 1 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/算法/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      redis 算法研究
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-_Redis_key和value的存储形式">1. Redis key和value的存储形式</h1>
<h2 id="1-1-_基本数据结构">1.1. 基本数据结构</h2>
<p>redis中使用hashmap存储key和对应的value。hashmap的定义如下：</p>
<pre><code>typedef <span class="keyword">struct</span> dict {
    dictType *<span class="class"><span class="keyword">type</span>;</span>
    <span class="keyword">void</span> *privdata;
    dictht ht[<span class="number">2</span>];
    long rehashidx; /* rehashing not <span class="keyword">in</span> progress <span class="keyword">if</span> rehashidx == -<span class="number">1</span> */
    int iterators; /* number <span class="keyword">of</span> iterators currently running */
} dict; 
</code></pre><p><a id="more"></a><br>其中dictht ht[2] 就是数据实际存储的hash map。dictht的结构如下：</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">struct</span> dictht {
    dictEntry **table;
    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;
    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;
    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;
} dictht;
</code></pre><p>在dictht中，table就是存储map数据的广义表指针。map中的每一个entity（即key和value对）使用dictEntry来表示，dictEntry的结构如下：</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">struct</span> dictEntry {
    <span class="keyword">void</span> *key;
    <span class="keyword">union</span> {
        <span class="keyword">void</span> *val;
        uint64_t u64;
        int64_t s64;
        <span class="built_in">double</span> d;
    } v;
    <span class="keyword">struct</span> dictEntry *next;
} dictEntry;
</code></pre><p>dictEntry表示map中的一个键值对,其中v是键值对的value，是一个64位的union，其表示格式如下：<br>    typedef struct redisObject {<br>        unsigned type:4;<br>        unsigned encoding:4;<br>        unsigned lru:REDIS_LRU_BITS; /<em> lru time (relative to server.lruclock) </em>/<br>        int refcount;<br>        void *ptr;<br>    } robj;<br>按照robj计算，tpye+encoding+lru+refcount+ptr = 4+4+24+16+16 = 64. 值的type可以取下面的值：</p>
<pre><code><span class="preprocessor">#<span class="keyword">define</span> REDIS_STRING 0</span>
<span class="preprocessor">#<span class="keyword">define</span> REDIS_LIST 1</span>
<span class="preprocessor">#<span class="keyword">define</span> REDIS_SET 2</span>
<span class="preprocessor">#<span class="keyword">define</span> REDIS_ZSET 3</span>
<span class="preprocessor">#<span class="keyword">define</span> REDIS_HASH 4</span>
<span class="preprocessor">#<span class="keyword">define</span> REDIS_HASH_ZIPMAP 9</span>
<span class="preprocessor">#<span class="keyword">define</span> REDIS_LIST_ZIPLIST 10</span>
<span class="preprocessor">#<span class="keyword">define</span> REDIS_SET_INTSET 11</span>
<span class="preprocessor">#<span class="keyword">define</span> REDIS_ZSET_ZIPLIST 12</span>
<span class="preprocessor">#<span class="keyword">define</span> REDIS_HASH_ZIPLIST 13</span>
</code></pre><p>encoding可以取以下的值：</p>
<pre><code><span class="preprocessor">#<span class="keyword">define</span> REDIS_ENCODING_RAW 0    /* Raw representation */</span>
<span class="preprocessor">#<span class="keyword">define</span> REDIS_ENCODING_INT 1    /* Encoded as integer */</span>
<span class="preprocessor">#<span class="keyword">define</span> REDIS_ENCODING_ZIPMAP 2 /* Encoded as zipmap */</span>
<span class="preprocessor">#<span class="keyword">define</span> REDIS_ENCODING_HT 3     /* Encoded as a hash table */</span>
</code></pre><p>redis的hashmap形式如下图：<br><img src="/blog/pic/redis/redis_table.png" alt="redis table"><br>从图中可以看出，redis中用于存储key和value的hashmap，实际上是一个纵向为一维数组，横向为链表结构的广义表。从下面的代码可以得出这个结论。</p>
<pre><code>n.table = <span class="built_in">calloc</span>(realsize,<span class="keyword">sizeof</span>(dictEntry*));
</code></pre><p>这样做的好处是，在查找某个key时，通过hash算法求出key值对应的数组下标，获取相同hash值的链表后，遍历链表获取对应key值即可。获取过程如下：</p>
<pre><code><span class="keyword">static</span> dictEntry *dictFind(dict *ht, <span class="keyword">const</span> <span class="keyword">void</span> *key) {
    dictEntry *he;
    <span class="keyword">unsigned</span> <span class="keyword">int</span> h;

    <span class="keyword">if</span> (ht-&gt;size == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;
    h = dictHashKey(ht, key) &amp; ht-&gt;sizemask;<span class="comment">//计算hash值，即table数组下标</span>
    he = ht-&gt;table[h];<span class="comment">//he表示具有与请求key相同hash值的entity列表</span>
    <span class="keyword">while</span>(he) {<span class="comment">//遍历这个列表，获取到与请求key相等的entity，并返回</span>
        <span class="keyword">if</span> (dictCompareHashKeys(ht, key, he-&gt;key))
            <span class="keyword">return</span> he;
        he = he-&gt;next;
    }
    <span class="keyword">return</span> <span class="literal">NULL</span>;
}
</code></pre><h2 id="1-2-_redis_过期时间">1.2. redis 过期时间</h2>
<p>redis的db结构定义如下：</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">struct</span> redisDb {
    dict *dict;                 <span class="comment">/* The keyspace for this DB */</span>
    dict *expires;              <span class="comment">/* Timeout of keys with a timeout set */</span>
    dict *blocking_keys;        <span class="comment">/* Keys with clients waiting for data (BLPOP) */</span>
    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span>
    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span>
    <span class="keyword">int</span> <span class="keyword">id</span>;
    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;          <span class="comment">/* Average TTL, just for stats */</span>
} redisDb;
</code></pre><p>其中dict用于存储redis中的key和value键值对。expires与key-value的dict相似也是个map，如果在设置key时，设置了过期时间，那么对应的在expires中会添加一个对应的key-expire键值对。需要访问某个key时，redis需要先判断这个key是否过期，如下代码：</p>
<pre><code>long long getExpire(redisDb <span class="subst">*</span>db, robj <span class="subst">*</span>key) {
    dictEntry <span class="subst">*</span>de;

    <span class="comment">/* No expire? return ASAP */</span>
    <span class="keyword">if</span> (dictSize(db<span class="subst">-&gt;</span>expires) <span class="subst">==</span> <span class="number">0</span> <span class="subst">||</span>
       (de <span class="subst">=</span> dictFind(db<span class="subst">-&gt;</span>expires,key<span class="subst">-&gt;</span>ptr)) <span class="subst">==</span> <span class="built_in">NULL</span>) <span class="keyword">return</span> <span class="subst">-</span><span class="number">1</span>;

    <span class="comment">/* The entry was found in the expire dict, this means it should also be present in the main dict (safety check). */</span>
    redisAssertWithInfo(<span class="built_in">NULL</span>,key,dictFind(db<span class="subst">-&gt;</span>dict,key<span class="subst">-&gt;</span>ptr) <span class="subst">!=</span> <span class="built_in">NULL</span>);
    <span class="keyword">return</span> dictGetSignedIntegerVal(de);
}
</code></pre><p>其中dictGetSignedIntegerVal定义如下：</p>
<pre><code><span class="preprocessor">#<span class="keyword">define</span> dictGetSignedIntegerVal(he) ((he)-&gt;v.s64)</span>
</code></pre><p>可以看出<code>(he)-&gt;v.s64</code>使用的是dict定义中union的s64而不是val，这也是dic为什么使用union的原因。<br><br>此外，如果没有为key设置过期时间，那么会节省很多空间。</p>
<h2 id="1-3-_渐进式rehash">1.3. 渐进式rehash</h2>
<p>当hashtable中承载了过多的entity后，添加新key值时，冲突情况会越来越多，并且table中每个list长度会不断增长，此时查找key需要消耗更多时间。因此，当entity量足够大时，table需要rehash。如果使用传统hash算法，当redis中存在大量的entity时，将一个hash table的数据全部拷贝到新table中，将会消耗大量时间，因此，redis使用渐进式rehash。</p><p><br>在dict的数据结构中（<code>dictht ht[2];</code>）创建两个dictht，其中ht[0]表示旧的hashtable，ht[1]表示新hashtable。当ht[0]中有过多的entity后，redis为ht[1]分配一个足够大（一般是原table的两倍）的空间，新添加的entity都会放到ht[1]中，每当key查询时，如果ht[0]仍然有数据（通过<code>long rehashidx;</code>是否大于-1判断），就将ht[0]的一行数据（就是一个list列表）取出，对列表的每个entity重新计算，并放到ht[1]中。当系统继续运行一段时间后，所有数据都只在ht[1]中，此时ht[0]就可以释放空间（<code>long rehashidx;</code>被设置成-1），ht[0]空间释放后，将ht[0]指向ht[1]。例如，在dictFind中包含如下语句：<code>if (dictIsRehashing(d)) _dictRehashStep(d);</code>,可以看出，每次查找key时，都会判断是否在rehash（通过判断rehashidx），如果ht[0]中还有元素没有移过来，会调用_dictRehashStep.(参考dic.c中的<code>dictRehash</code>函数）。</p>
<h1 id="2-_redis_list">2. redis list</h1>
<p>redis list使用了两种存储方式，分别是双向链表（REDIS_ENCODING_LINKEDLIST）和zip list（REDIS_ENCODING_ZIPLIST）</p>
<h2 id="2-1_REDIS_ENCODING_LINKEDLIST">2.1 REDIS_ENCODING_LINKEDLIST</h2>
<p>redis中双向列表的定义如下：</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">struct</span> listNode {
    <span class="keyword">struct</span> listNode *prev;
    <span class="keyword">struct</span> listNode *next;
    <span class="keyword">void</span> *value;
} listNode;

<span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">list</span> {
    listNode *head;
    listNode *tail;
    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);
    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);
    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);
    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;
} <span class="built_in">list</span>;
</code></pre><h2 id="2-2_REDIS_ENCODING_ZIPLIST">2.2 REDIS_ENCODING_ZIPLIST</h2>
<p>zip list是一种压缩格式，整个list编码成一个string，list的编码格式如下：</p>
<pre><code><span class="tag">&lt;<span class="title">zlbytes</span>&gt;</span><span class="tag">&lt;<span class="title">zltail</span>&gt;</span><span class="tag">&lt;<span class="title">zllen</span>&gt;</span><span class="tag">&lt;<span class="title">entry</span>&gt;</span><span class="tag">&lt;<span class="title">entry</span>&gt;</span><span class="tag">&lt;<span class="title">zlend</span>&gt;</span>
</code></pre><p>zlbytes： 4bytes 用于表示整个zip list包含多少byte数据。<br><br>zltail：4bytes 用于表示列表最后一个元素与列表起始元素之间的偏移量，方便逆序访问list快速定位list的最后的entity。<br><br>zllen: 2bytes 用于表示zip list中entity的数量。<br><br>entry：list中单个元素的数据信息。<br><br>zlend：1byte 永远是255，表示list的末尾。<br><br>list中的每个entity由如下格式组成：</p>
<pre><code><span class="subst">&lt;</span>length<span class="attribute">-prev</span><span class="attribute">-entry</span><span class="subst">&gt;&lt;</span>special<span class="attribute">-flag</span><span class="subst">&gt;&lt;</span>raw<span class="attribute">-bytes</span><span class="attribute">-of</span><span class="attribute">-entry</span><span class="subst">&gt;</span>
</code></pre><p>length-prev-entry：表示当前entity的前一个entity的长度，在反向遍历时，用于快速定位前驱元素的位置；<br><br>special-flag：entity数据实际存储的类型（可能是不同长度string的编码、或者是不同长度整形的编码等，详见Redis RDB File Format）<br>raw-bytes-of-entry:entity 的实际存储的数据，具体类型有special-flag决定。<br><br><strong>注意:zltail元素的用法，根据entity的格式，很容易找到某个entity的前驱和后继元素（前驱通过length-prev-entry定位，后继就是当前元素解析后那个位置开始）对于逆序访问，需要定位最后一个entity的起始位置，因此，zltail用于快速定位最后一个元素的起始位置（如果zltail不存在，即使知道最后元素的结尾在哪里，但是entity是变长的，也无法推断出最后一个元素的起始位置）</strong><br></p>
<p>创建一个空zip list的源码如下：</p>
<pre><code><span class="preprocessor">#define ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))</span>
<span class="keyword">unsigned</span> <span class="keyword">char</span> *ziplistNew(<span class="keyword">void</span>) {
    <span class="keyword">unsigned</span> <span class="keyword">int</span> bytes = ZIPLIST_HEADER_SIZE+<span class="number">1</span>;<span class="comment">//32+32+16+1 = zlbytes+zltail+zllen+zlend</span>
    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = zmalloc(bytes);
    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);<span class="comment">//redis使用小端对齐</span>
    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);
    ZIPLIST_LENGTH(zl) = <span class="number">0</span>;
    zl[bytes-<span class="number">1</span>] = ZIP_END;
    <span class="keyword">return</span> zl;
}
</code></pre><p>将一个元素添加到list中：</p>
<pre><code><span class="comment">/* Insert item at "p". */</span>
<span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistInsert(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen) {
    size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;
    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevlensize, prevlen = <span class="number">0</span>;
    size_t offset;
    <span class="keyword">int</span> nextdiff = <span class="number">0</span>;
    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding = <span class="number">0</span>;
    <span class="keyword">long</span> <span class="keyword">long</span> value = <span class="number">123456789</span>; <span class="comment">/* initialized to avoid warning. Using a value
                                    that is easy to see if for some reason
                                    we use it uninitialized. */</span>
    zlentry tail;

    <span class="comment">/* Find out prevlen for the entry that is inserted. */</span>
    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) {<span class="comment">//在list的头部插入</span>
        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
    } <span class="keyword">else</span> {<span class="comment">//尾部插入</span>
        <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl);
        <span class="keyword">if</span> (ptail[<span class="number">0</span>] != ZIP_END) {
            prevlen = zipRawEntryLength(ptail);
        }
    }

    <span class="comment">/* See if the entry can be encoded */</span>
    <span class="keyword">if</span> (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) {<span class="comment">//能转换为整形的，就转换后存储</span>
        <span class="comment">/* 'encoding' is set to the appropriate integer encoding */</span>
        reqlen = zipIntSize(encoding);
    } <span class="keyword">else</span> {<span class="comment">//不能转换的，使用string存储</span>
        <span class="comment">/* 'encoding' is untouched, however zipEncodeLength will use the
         * string length to figure out how to encode it. */</span>
        reqlen = slen;
    }
    <span class="comment">/* We need space for both the length of the previous entry and
     * the length of the payload. */</span>
    reqlen += zipPrevEncodeLength(<span class="literal">NULL</span>,prevlen);
    reqlen += zipEncodeLength(<span class="literal">NULL</span>,encoding,slen);

    <span class="comment">/* When the insert position is not equal to the tail, we need to
     * make sure that the next entry can hold this entry's length in
     * its prevlen field. */</span>
    nextdiff = (p[<span class="number">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : <span class="number">0</span>;

    <span class="comment">/* Store offset because a realloc may change the address of zl. */</span>
    offset = p-zl;
    zl = ziplistResize(zl,curlen+reqlen+nextdiff);
    p = zl+offset;

    <span class="comment">/* Apply memory move when necessary and update tail offset. */</span>
    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) {<span class="comment">//在头部插入，需要移动元素</span>
        <span class="comment">/* Subtract one because of the ZIP_END bytes */</span>
        memmove(p+reqlen,p-nextdiff,curlen-offset-<span class="number">1</span>+nextdiff);

        <span class="comment">/* Encode this entry's raw length in the next entry. */</span>
        zipPrevEncodeLength(p+reqlen,reqlen);

        <span class="comment">/* Update offset for tail */</span>
        ZIPLIST_TAIL_OFFSET(zl) =
            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);

        <span class="comment">/* When the tail contains more than one entry, we need to take
         * "nextdiff" in account as well. Otherwise, a change in the
         * size of prevlen doesn't have an effect on the *tail* offset. */</span>
        tail = zipEntry(p+reqlen);
        <span class="keyword">if</span> (p[reqlen+tail<span class="variable">.headersize</span>+tail<span class="variable">.len</span>] != ZIP_END) {
            ZIPLIST_TAIL_OFFSET(zl) =
                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);
        }
    } <span class="keyword">else</span> {
        <span class="comment">/* This element will be the new tail. */</span>
        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);
    }

    <span class="comment">/* When nextdiff != 0, the raw length of the next entry has changed, so
     * we need to cascade the update throughout the ziplist */</span>
    <span class="keyword">if</span> (nextdiff != <span class="number">0</span>) {
        offset = p-zl;
        zl = __ziplistCascadeUpdate(zl,p+reqlen);
        p = zl+offset;
    }

    <span class="comment">/* Write the entry */</span>
    p += zipPrevEncodeLength(p,prevlen);
    p += zipEncodeLength(p,encoding,slen);
    <span class="keyword">if</span> (ZIP_IS_STR(encoding)) {
        memcpy(p,s,slen);
    } <span class="keyword">else</span> {
        zipSaveInteger(p,value,encoding);
    }
    ZIPLIST_INCR_LENGTH(zl,<span class="number">1</span>);
    <span class="keyword">return</span> zl;
}
</code></pre><p>在存储过程中，能转换成整型的value会尽量转换成数字存储，从而节省空间：</p>
<pre><code><span class="comment">/* Check if string pointed to by 'entry' can be encoded as an integer.
 * Stores the integer value in 'v' and its encoding in 'encoding'. */</span>
<span class="keyword">static</span> <span class="keyword">int</span> zipTryEncoding(unsigned <span class="keyword">char</span> *entry, unsigned <span class="keyword">int</span> entrylen, <span class="keyword">long</span> <span class="keyword">long</span> *v, unsigned <span class="keyword">char</span> *encoding) {
    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">value</span>;

    <span class="keyword">if</span> (entrylen &gt;= <span class="number">32</span> || entrylen == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">if</span> (string2ll((<span class="keyword">char</span>*)entry,entrylen,&amp;<span class="keyword">value</span>)) {
        <span class="comment">/* Great, the string can be encoded. Check what's the smallest
         * of our encoding types that can hold this value. */</span>
        <span class="keyword">if</span> (<span class="keyword">value</span> &gt;= <span class="number">0</span> &amp;&amp; <span class="keyword">value</span> &lt;= <span class="number">12</span>) {
            *encoding = ZIP_INT_IMM_MIN+<span class="keyword">value</span>;
        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">value</span> &gt;= INT8_MIN &amp;&amp; <span class="keyword">value</span> &lt;= INT8_MAX) {
            *encoding = ZIP_INT_8B;
        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">value</span> &gt;= INT16_MIN &amp;&amp; <span class="keyword">value</span> &lt;= INT16_MAX) {
            *encoding = ZIP_INT_16B;
        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">value</span> &gt;= INT24_MIN &amp;&amp; <span class="keyword">value</span> &lt;= INT24_MAX) {
            *encoding = ZIP_INT_24B;
        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">value</span> &gt;= INT32_MIN &amp;&amp; <span class="keyword">value</span> &lt;= INT32_MAX) {
            *encoding = ZIP_INT_32B;
        } <span class="keyword">else</span> {
            *encoding = ZIP_INT_64B;
        }
        *v = <span class="keyword">value</span>;
        <span class="keyword">return</span> <span class="number">1</span>;
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>从上面的过程可以看出，使用ziplist存储较小的数据会很高效。</p>
<h2 id="2-3_list_和_ziplist转换">2.3 list 和 ziplist转换</h2>
<p>ziplist在存储空间上，比list节省的多，这种压缩格式对于entity value值比较小（例如是int类型、或者较短的string类型）存储效率会非常高，例如，存储一个32位的整数list，每个元素占用空间（length-prev-entry+special-flag+raw-bytes-of-entry = 2+1+4 = 7bytes）比list类型占用的空间（prev+next+value = 4+4+4 = 12bytes）高效的多。当某个list的单个元素很小时适合使用ziplist存储列表，可以通过<br><code>list-max-ziplist-value</code>参数指定使用ziplist存储的元素上限。默认为64.<br><br>另一方面，由于每次对ziplist的修改，都会导致整个string的resize，当entity的数量较多时，显然使用ziplist是不适当的，会消耗大量的cpu时间并且降低了操作的相应速度，可以通过<code>list-max-ziplist-entries</code>参数调节使用ziplist的最大entity数量，默认为512.<br></p>
<h2 id="2-4_list的block实现">2.4 list的block实现</h2>
<p>redis中list提供block操作，简单说，请求获取list中元素时，如果list中尚未有可返回的元素，请求即被阻塞，直至有其它请求向list中添加元素为止。<br><br>redis中list有三种block操作，分别是blpop、brpop、brpoplpush。<br><br>redisClient中有一个blockingState类型的属性，用于记录当前请求等待哪些list keys，blockingState定义如下：</p>
<pre><code>typedef struct blockingState {
    dict *keys;             /* The keys we are waiting <span class="keyword">to</span> terminate a blocking
                             * operation such <span class="keyword">as</span> BLPOP. Otherwise NULL. */
    time_t <span class="keyword">timeout</span>;         /* Blocking operation <span class="keyword">timeout</span>. If UNIX current <span class="property">time</span>
                             * <span class="keyword">is</span> &gt;= <span class="keyword">timeout</span> <span class="keyword">then</span> <span class="keyword">the</span> operation timed out. */
    robj *target;           /* The key <span class="keyword">that</span> should receive <span class="keyword">the</span> element,
                             * <span class="keyword">for</span> BRPOPLPUSH. */
} blockingState;
</code></pre><p>此外，redisDB中有两个dict类型的属性，blocking_keys用于记录阻塞的key和clients的映射关系(注意，这里的clients是一个list，很多个client可以在同一个key上阻塞)，ready_keys用于记录收到push请求的blocking_keys（ready_keys实际相当于一个set，其只记录了key，所有的val都是null）。<br><br>在server层面上，也有一个ready_keys,类型却为list，其中每个元素定义如下：</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">struct</span> readyList {
    redisDb *db;<span class="comment">//哪个数据库</span>
    robj *key;<span class="comment">//对应的key</span>
} readyList;
</code></pre><p>从上述定义可以看出，一个server实际上是由多个db组成，而server的ready_keys记录了key和对应db的关系。<strong>注意，不同的db可能有相同的key，因此server层面的ready_keys没有选用hash结构</strong></p>
<p>下面以blpop为例，说明算法流程：<br></p>
<ol>
<li>请求blpop，并且key对应的list非空，blpop内部直接调用lpop，返回结果，此时，调用blpop与lpop没有区别；</li>
<li>blpop调用时，请求的key不存在或者key对应的list为空，此时request需要block。redis清理掉请求的接收数据标记，以保证在block过程中，不会在这个链接中读取数据。redis将请求的client添加到db-&gt;blocking_keys队列中。</li>
<li>当某个block的key接收到push请求后，会被放入ready_keys中，并且在当前指令、script、或者multi/exec block被执行时，redis会将list中所有的元素，依次赋值给blocking_keys对应key队列中的client。</li>
</ol>
<p>添加block key的源码片段（<code>函数blockForKeys</code>）：</p>
<pre><code><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numkeys<span class="javadoc">/**参数中可以订阅多个keys**/</span>; j++) {
    <span class="comment">/* If the key already exists in the dict ignore it. */</span>
    <span class="keyword">if</span> (dictAdd(c-&gt;bpop.keys,keys[j],NULL) != DICT_OK) <span class="keyword">continue</span>;

    <span class="comment">/* And in the other "side", to map keys -&gt; clients */</span>
    de = dictFind(c-&gt;db-&gt;blocking_keys,keys[j]);
    <span class="keyword">if</span> (de == NULL) {
        <span class="keyword">int</span> retval;
        <span class="comment">/* For every key we take a list of clients blocked for it */</span>
        l = listCreate();
        retval = dictAdd(c-&gt;db-&gt;blocking_keys,keys[j],l);
    } <span class="keyword">else</span> {
        l = dictGetVal(de);<span class="comment">//获取阻塞key对应的client列表</span>
    }
    listAddNodeTail(l,c);<span class="comment">//将当前阻塞的client，添加到列表的最后</span>
}
</code></pre><p>调用push命令后，向ready_keys中添加元素(<code>函数signalListAsReady</code>)</p>
<pre><code><span class="comment">/* No clients blocking for this key? No need to queue it. */</span>
<span class="keyword">if</span> (dictFind(c<span class="subst">-&gt;</span>db<span class="subst">-&gt;</span>blocking_keys,key) <span class="subst">==</span> <span class="built_in">NULL</span>) <span class="keyword">return</span>;

<span class="comment">/* Key was already signaled? No need to queue it again. */</span>
<span class="keyword">if</span> (dictFind(c<span class="subst">-&gt;</span>db<span class="subst">-&gt;</span>ready_keys,key) <span class="subst">!=</span> <span class="built_in">NULL</span>) <span class="keyword">return</span>;

<span class="comment">/* Ok, we need to queue this key into server.ready_keys. */</span>
rl <span class="subst">=</span> zmalloc(sizeof(<span class="subst">*</span>rl));
rl<span class="subst">-&gt;</span>key <span class="subst">=</span> key;
rl<span class="subst">-&gt;</span>db <span class="subst">=</span> c<span class="subst">-&gt;</span>db;
listAddNodeTail(server<span class="built_in">.</span>ready_keys,rl);<span class="comment">//先添加到server的ready_key中</span>
redisAssert(dictAdd(c<span class="subst">-&gt;</span>db<span class="subst">-&gt;</span>ready_keys,key,<span class="built_in">NULL</span>) <span class="subst">==</span> DICT_OK);<span class="comment">//再添加到db的ready_keys中</span>
</code></pre><p>从上面的代码中可以看出，db-&gt;ready_keys只是用作过滤某个key是否已经添加到server-&gt;ready_keys中，由于server-&gt;ready_keys是一个list，如果通过遍历list判断某个key是否在server-&gt;ready_keys中，要消耗更多的时间，因此,db-&gt;ready_keys相当一个set，过滤那些已经添加到server-&gt;ready_keys中的元素。<br></p>
<p>最后，当有命令被执行时，调用释放block</p>
<pre><code><span class="comment">/* Point server.ready_keys to a fresh list and save the current one
    * locally. This way as we run the old list we are free to call
    * signalListAsReady() that may push new elements in server.ready_keys
    * when handling clients blocked into BRPOPLPUSH. */</span>
l <span class="subst">=</span> server<span class="built_in">.</span>ready_keys;
server<span class="built_in">.</span>ready_keys <span class="subst">=</span> listCreate();

<span class="keyword">while</span>(listLength(l) <span class="subst">!=</span> <span class="number">0</span>) {
    listNode <span class="subst">*</span>ln <span class="subst">=</span> listFirst(l);
    readyList <span class="subst">*</span>rl <span class="subst">=</span> ln<span class="subst">-&gt;</span>value;

    <span class="comment">/* First of all remove this key from db-&gt;ready_keys so that
     * we can safely call signalListAsReady() against this key. */</span>
    dictDelete(rl<span class="subst">-&gt;</span>db<span class="subst">-&gt;</span>ready_keys,rl<span class="subst">-&gt;</span>key);<span class="comment">//保证处理key时，也可以添加block_ready</span>

    <span class="comment">/* If the key exists and it's a list, serve blocked clients
    * with data. */</span>
    robj <span class="subst">*</span>o <span class="subst">=</span> lookupKeyWrite(rl<span class="subst">-&gt;</span>db,rl<span class="subst">-&gt;</span>key);
    <span class="keyword">if</span> (o <span class="subst">!=</span> <span class="built_in">NULL</span> <span class="subst">&amp;&amp;</span> o<span class="subst">-&gt;</span><span class="keyword">type</span> <span class="subst">==</span> REDIS_LIST) {
        dictEntry <span class="subst">*</span>de;

        <span class="comment">/* We serve clients in the same order they blocked for
          * this key, from the first blocked to the last. */</span>
        de <span class="subst">=</span> dictFind(rl<span class="subst">-&gt;</span>db<span class="subst">-&gt;</span>blocking_keys,rl<span class="subst">-&gt;</span>key);
        <span class="keyword">if</span> (de) {
            <span class="built_in">list</span> <span class="subst">*</span>clients <span class="subst">=</span> dictGetVal(de);<span class="comment">//获取到client</span>
            int numclients <span class="subst">=</span> listLength(clients);

               <span class="keyword">while</span>(numclients<span class="subst">--</span>) {
                listNode <span class="subst">*</span>clientnode <span class="subst">=</span> listFirst(clients);
                redisClient <span class="subst">*</span>receiver <span class="subst">=</span> clientnode<span class="subst">-&gt;</span>value;
                robj <span class="subst">*</span>dstkey <span class="subst">=</span> receiver<span class="subst">-&gt;</span>bpop<span class="built_in">.</span>target;
                int <span class="keyword">where</span> <span class="subst">=</span> (receiver<span class="subst">-&gt;</span>lastcmd <span class="subst">&amp;&amp;</span>
                             receiver<span class="subst">-&gt;</span>lastcmd<span class="subst">-&gt;</span>proc <span class="subst">==</span> blpopCommand) <span class="subst">?</span>
                            REDIS_HEAD : REDIS_TAIL;
                robj <span class="subst">*</span>value <span class="subst">=</span> listTypePop(o,<span class="keyword">where</span>);

                <span class="keyword">if</span> (value) {
                    <span class="comment">/* Protect receiver-&gt;bpop.target, that will be
                     * freed by the next unblockClientWaitingData()
                     * call. */</span>
                    unblockClientWaitingData(receiver);<span class="comment">//client现在可以继续接受输入数据</span>

                    <span class="keyword">if</span> (serveClientBlockedOnList(receiver,
                        rl<span class="subst">-&gt;</span>key,dstkey,rl<span class="subst">-&gt;</span>db,value,
                        <span class="keyword">where</span>) <span class="subst">==</span> REDIS_ERR)<span class="comment">//将需要的数据返回给客户端</span>
                    {
                        <span class="comment">/* If we failed serving the client we need
                         * to also undo the POP operation. */</span>
                            listTypePush(o,value,<span class="keyword">where</span>);
                    }
                } <span class="keyword">else</span> {
                    break;
                }
    }
}

<span class="keyword">if</span> (listTypeLength(o) <span class="subst">==</span> <span class="number">0</span>) dbDelete(rl<span class="subst">-&gt;</span>db,rl<span class="subst">-&gt;</span>key);
<span class="comment">/* We don't call signalModifiedKey() as it was already called
 * when an element was pushed on the list. */</span>
}
</code></pre><h1 id="参考资料：">参考资料：</h1>
<p>Redis RDB File Format：<a href="https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format" target="_blank" rel="external">https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://guanxinquan.github.io/blog/2014/10/01/redis/" data-id="ffqk1adsmjw9lvwe" class="article-share-link">Share</a>
      
        <a href="http://guanxinquan.github.io/blog/2014/10/01/redis/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/redis/">redis</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/blog/2014/07/10/gc/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">java 虚拟机垃圾回收原理</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/算法/">算法</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/fst/">fst</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/gc/">gc</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/redis/">redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/生活/">生活</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/fst/" style="font-size: NaNpx;">fst</a><a href="/blog/tags/gc/" style="font-size: NaNpx;">gc</a><a href="/blog/tags/redis/" style="font-size: NaNpx;">redis</a><a href="/blog/tags/生活/" style="font-size: NaNpx;">生活</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/10">October 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/07">July 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/06">June 2014</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2014/10/01/redis/">redis 算法研究</a>
          </li>
        
          <li>
            <a href="/blog/2014/07/10/gc/">java 虚拟机垃圾回收原理</a>
          </li>
        
          <li>
            <a href="/blog/2014/06/17/lucene_FST_parser/">lucene中的FST算法分析</a>
          </li>
        
          <li>
            <a href="/blog/2014/06/17/firstblog/">青春纪念</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2014 xinquan.guan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog//" class="mobile-nav-link">Home</a>
  
    <a href="/blog//archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'httpguanxinquangithubio';
  
  var disqus_url = 'http://guanxinquan.github.io/blog/2014/10/01/redis/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//go.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/blog/js/script.js" type="text/javascript"></script>
  </div>
</body>
</html>