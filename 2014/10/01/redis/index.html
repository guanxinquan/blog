<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>redis 算法研究 | MR.GUAN</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1. Redis key和value的存储形式
1.1. 基本数据结构
redis中使用hashmap存储key和对应的value。hashmap的定义如下：
typedef struct dict {
    dictType *type;
    void *privdata;
    dictht ht[2];
    long rehashidx; /* rehashing not in">
<meta property="og:type" content="article">
<meta property="og:title" content="redis 算法研究">
<meta property="og:url" content="http://guanxinquan.github.io/blog/blog/2014/10/01/redis/">
<meta property="og:site_name" content="MR.GUAN">
<meta property="og:description" content="1. Redis key和value的存储形式
1.1. 基本数据结构
redis中使用hashmap存储key和对应的value。hashmap的定义如下：
typedef struct dict {
    dictType *type;
    void *privdata;
    dictht ht[2];
    long rehashidx; /* rehashing not in">
<meta property="og:image" content="/blog/pic/redis/redis_table.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="redis 算法研究">
<meta name="twitter:description" content="1. Redis key和value的存储形式
1.1. 基本数据结构
redis中使用hashmap存储key和对应的value。hashmap的定义如下：
typedef struct dict {
    dictType *type;
    void *privdata;
    dictht ht[2];
    long rehashidx; /* rehashing not in">
  
    <link rel="alternative" href="/atom.xml" title="MR.GUAN" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/blog/css/style.css" type="text/css">
  
</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog//" id="logo">MR.GUAN</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog//">Home</a>
        
          <a class="main-nav-link" href="/blog//archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="submit" value="&#xF002;" class="search-form-submit"><input type="hidden" name="q" value="site:http://guanxinquan.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-redis" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2014/10/01/redis/" class="article-date">
  <time datetime="2014-10-01T04:45:00.000Z" itemprop="datePublished">Oct 1 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/算法/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      redis 算法研究
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-_Redis_key和value的存储形式">1. Redis key和value的存储形式</h1>
<h1 id="1-1-_基本数据结构">1.1. 基本数据结构</h1>
<p>redis中使用hashmap存储key和对应的value。hashmap的定义如下：</p>
<pre><code>typedef <span class="keyword">struct</span> dict {
    dictType *<span class="class"><span class="keyword">type</span>;</span>
    <span class="keyword">void</span> *privdata;
    dictht ht[<span class="number">2</span>];
    long rehashidx; /* rehashing not <span class="keyword">in</span> progress <span class="keyword">if</span> rehashidx == -<span class="number">1</span> */
    int iterators; /* number <span class="keyword">of</span> iterators currently running */
} dict; 
</code></pre><p><a id="more"></a><br>其中dictht ht[2] 就是数据实际存储的hash map。dictht的结构如下：</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">struct</span> dictht {
    dictEntry **table;
    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;
    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;
    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;
} dictht;
</code></pre><p>在dictht中，table就是存储map数据的广义表指针。map中的每一个entity（即key和value对）使用dictEntry来表示，dictEntry的结构如下：</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">struct</span> dictEntry {
    <span class="keyword">void</span> *key;
    <span class="keyword">union</span> {
        <span class="keyword">void</span> *val;
        uint64_t u64;
        int64_t s64;
        <span class="built_in">double</span> d;
    } v;
    <span class="keyword">struct</span> dictEntry *next;
} dictEntry;
</code></pre><p>dictEntry表示map中的一个键值对,其中v是键值对的value，是一个64位的union，其表示格式如下：<br>    typedef struct redisObject {<br>        unsigned type:4;<br>        unsigned encoding:4;<br>        unsigned lru:REDIS_LRU_BITS; /<em> lru time (relative to server.lruclock) </em>/<br>        int refcount;<br>        void *ptr;<br>    } robj;<br>按照robj计算，tpye+encoding+lru+refcount+ptr = 4+4+24+16+16 = 64. 值的type可以取下面的值：</p>
<pre><code><span class="preprocessor">#<span class="keyword">define</span> REDIS_STRING 0</span>
<span class="preprocessor">#<span class="keyword">define</span> REDIS_LIST 1</span>
<span class="preprocessor">#<span class="keyword">define</span> REDIS_SET 2</span>
<span class="preprocessor">#<span class="keyword">define</span> REDIS_ZSET 3</span>
<span class="preprocessor">#<span class="keyword">define</span> REDIS_HASH 4</span>
<span class="preprocessor">#<span class="keyword">define</span> REDIS_HASH_ZIPMAP 9</span>
<span class="preprocessor">#<span class="keyword">define</span> REDIS_LIST_ZIPLIST 10</span>
<span class="preprocessor">#<span class="keyword">define</span> REDIS_SET_INTSET 11</span>
<span class="preprocessor">#<span class="keyword">define</span> REDIS_ZSET_ZIPLIST 12</span>
<span class="preprocessor">#<span class="keyword">define</span> REDIS_HASH_ZIPLIST 13</span>
</code></pre><p>encoding可以取以下的值：</p>
<pre><code><span class="preprocessor">#<span class="keyword">define</span> REDIS_ENCODING_RAW 0    /* Raw representation */</span>
<span class="preprocessor">#<span class="keyword">define</span> REDIS_ENCODING_INT 1    /* Encoded as integer */</span>
<span class="preprocessor">#<span class="keyword">define</span> REDIS_ENCODING_ZIPMAP 2 /* Encoded as zipmap */</span>
<span class="preprocessor">#<span class="keyword">define</span> REDIS_ENCODING_HT 3     /* Encoded as a hash table */</span>
</code></pre><p>redis的hashmap形式如下图：<br><img src="/blog/pic/redis/redis_table.png" alt="redis table"><br>从图中可以看出，redis中用于存储key和value的hashmap，实际上是一个纵向为一维数组，横向为链表结构的广义表。从下面的代码可以得出这个结论。</p>
<pre><code>n.table = <span class="built_in">calloc</span>(realsize,<span class="keyword">sizeof</span>(dictEntry*));
</code></pre><p>这样做的好处是，在查找某个key时，通过hash算法求出key值对应的数组下标，获取相同hash值的链表后，遍历链表获取对应key值即可。获取过程如下：</p>
<pre><code><span class="keyword">static</span> dictEntry *dictFind(dict *ht, <span class="keyword">const</span> <span class="keyword">void</span> *key) {
    dictEntry *he;
    <span class="keyword">unsigned</span> <span class="keyword">int</span> h;

    <span class="keyword">if</span> (ht-&gt;size == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;
    h = dictHashKey(ht, key) &amp; ht-&gt;sizemask;<span class="comment">//计算hash值，即table数组下标</span>
    he = ht-&gt;table[h];<span class="comment">//he表示具有与请求key相同hash值的entity列表</span>
    <span class="keyword">while</span>(he) {<span class="comment">//遍历这个列表，获取到与请求key相等的entity，并返回</span>
        <span class="keyword">if</span> (dictCompareHashKeys(ht, key, he-&gt;key))
            <span class="keyword">return</span> he;
        he = he-&gt;next;
    }
    <span class="keyword">return</span> <span class="literal">NULL</span>;
}
</code></pre><h2 id="1-2-_redis_过期时间">1.2. redis 过期时间</h2>
<p>redis的db结构定义如下：</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">struct</span> redisDb {
    dict *dict;                 <span class="comment">/* The keyspace for this DB */</span>
    dict *expires;              <span class="comment">/* Timeout of keys with a timeout set */</span>
    dict *blocking_keys;        <span class="comment">/* Keys with clients waiting for data (BLPOP) */</span>
    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span>
    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span>
    <span class="keyword">int</span> <span class="keyword">id</span>;
    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;          <span class="comment">/* Average TTL, just for stats */</span>
} redisDb;
</code></pre><p>其中dict用于存储redis中的key和value键值对。expires与key-value的dict相似也是个map，如果在设置key时，设置了过期时间，那么对应的在expires中会添加一个对应的key-expire键值对。需要访问某个key时，redis需要先判断这个key是否过期，如下代码：</p>
<pre><code>long long getExpire(redisDb <span class="subst">*</span>db, robj <span class="subst">*</span>key) {
    dictEntry <span class="subst">*</span>de;

    <span class="comment">/* No expire? return ASAP */</span>
    <span class="keyword">if</span> (dictSize(db<span class="subst">-&gt;</span>expires) <span class="subst">==</span> <span class="number">0</span> <span class="subst">||</span>
       (de <span class="subst">=</span> dictFind(db<span class="subst">-&gt;</span>expires,key<span class="subst">-&gt;</span>ptr)) <span class="subst">==</span> <span class="built_in">NULL</span>) <span class="keyword">return</span> <span class="subst">-</span><span class="number">1</span>;

    <span class="comment">/* The entry was found in the expire dict, this means it should also be present in the main dict (safety check). */</span>
    redisAssertWithInfo(<span class="built_in">NULL</span>,key,dictFind(db<span class="subst">-&gt;</span>dict,key<span class="subst">-&gt;</span>ptr) <span class="subst">!=</span> <span class="built_in">NULL</span>);
    <span class="keyword">return</span> dictGetSignedIntegerVal(de);
}
</code></pre><p>其中dictGetSignedIntegerVal定义如下：</p>
<pre><code><span class="preprocessor">#<span class="keyword">define</span> dictGetSignedIntegerVal(he) ((he)-&gt;v.s64)</span>
</code></pre><p>可以看出<code>(he)-&gt;v.s64</code>使用的是dict定义中union的s64而不是val，这也是dic为什么使用union的原因。<br><br>此外，如果没有为key设置过期时间，那么会节省很多空间。</p>
<h2 id="1-3-_渐进式rehash">1.3. 渐进式rehash</h2>
<p>当hashtable中承载了过多的entity后，添加新key值时，冲突情况会越来越多，并且table中每个list长度会不断增长，此时查找key需要消耗更多时间。因此，当entity量足够大时，table需要rehash。如果使用传统hash算法，当redis中存在大量的entity时，将一个hash table的数据全部拷贝到新table中，将会消耗大量时间，因此，redis使用渐进式rehash。</p><p><br>在dict的数据结构中（<code>dictht ht[2];</code>）创建两个dictht，其中ht[0]表示旧的hashtable，ht[1]表示新hashtable。当ht[0]中有过多的entity后，redis为ht[1]分配一个足够大（一般是原table的两倍）的空间，新添加的entity都会放到ht[1]中，每当key查询时，如果ht[0]仍然有数据（通过<code>long rehashidx;</code>是否大于-1判断），就将ht[0]的一行数据（就是一个list列表）取出，对列表的每个entity重新计算，并放到ht[1]中。当系统继续运行一段时间后，所有数据都只在ht[1]中，此时ht[0]就可以释放空间（<code>long rehashidx;</code>被设置成-1），ht[0]空间释放后，将ht[0]指向ht[1]。例如，在dictFind中包含如下语句：<code>if (dictIsRehashing(d)) _dictRehashStep(d);</code>,可以看出，每次查找key时，都会判断是否在rehash（通过判断rehashidx），如果ht[0]中还有元素没有移过来，会调用_dictRehashStep.(参考dic.c中的<code>dictRehash</code>函数）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://guanxinquan.github.io/blog/2014/10/01/redis/" data-id="n1wu3jnixdu9vhun" class="article-share-link">Share</a>
      
        <a href="http://guanxinquan.github.io/blog/2014/10/01/redis/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/redis/">redis</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/blog/2014/07/10/gc/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">java 虚拟机垃圾回收原理</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/算法/">算法</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/fst/">fst</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/gc/">gc</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/redis/">redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/生活/">生活</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/fst/" style="font-size: NaNpx;">fst</a><a href="/blog/tags/gc/" style="font-size: NaNpx;">gc</a><a href="/blog/tags/redis/" style="font-size: NaNpx;">redis</a><a href="/blog/tags/生活/" style="font-size: NaNpx;">生活</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/10">October 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/07">July 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/06">June 2014</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2014/10/01/redis/">redis 算法研究</a>
          </li>
        
          <li>
            <a href="/blog/2014/07/10/gc/">java 虚拟机垃圾回收原理</a>
          </li>
        
          <li>
            <a href="/blog/2014/06/17/lucene_FST_parser/">lucene中的FST算法分析</a>
          </li>
        
          <li>
            <a href="/blog/2014/06/17/firstblog/">青春纪念</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2014 xinquan.guan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog//" class="mobile-nav-link">Home</a>
  
    <a href="/blog//archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'httpguanxinquangithubio';
  
  var disqus_url = 'http://guanxinquan.github.io/blog/2014/10/01/redis/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//go.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/blog/js/script.js" type="text/javascript"></script>
  </div>
</body>
</html>